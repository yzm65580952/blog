# 8.12 Linux中的定时器：POSIX timer(上)

## POSIX定时器API
1. 编译链接：-lrt
2. int timer_create (clockid_t clockid, struct sigevent *sevp, timer_t *timerid);
3. int timer_gettime (timer_t timerid, struct itimerspec *curr_value);
4. int timer_settime (timer_t timerid, int flags, const struct itimerspec *new_value,struct itimerspec *old_value);
5. int timer_getoverrun (timer_t timerid);
6. int timer_delete (timer_t timerid);
### clockid
CLOCK_REALTIME：系统实时时间
CLOCK_MONOTONIC：系统启动以来的绝对时间
CLOCK_PROCESS_CPUTIME_ID：进程运行时间(用户和内核空间)
CLOCK_THREAD_CPUTIME_ID：线程运行时间(用户和内核空间)

### sevp
```c
typedef struct sigevent
{
__sigval_t sigev_value; // timer的ID
int sigev_signo; // 发送信号类型
int sigev_notify; // 定时器到期之后的动作：发信号、线程
void (*sigev_notify_function) (__sigval_t); /* Function to start. */
void *sigev_notify_attributes;  /* Really pthread_attr_t.*/
} sigevent_t;
```
#### sevp.sigev_notify
SIGEV_NONE：什么都不做
SIGEV_SIGNAL：发送信号给当前进程
SIGEV_THREAD：开启一个线程，执行用户指定function
SIGEV_THREAD_ID：给当前进程中的指定线程发信号
## demo
```c
#include <stdlib.h>
#include <unistd.h>
#include <stdio.h>
#include <signal.h>
#include <time.h>

static void signal_handler(int signo)
{
    printf("catch signal %d\n", signo);
}
     
int main(void)
{
    timer_t timerid;
    struct sigevent sev;
    struct itimerspec its;

	signal (SIGRTMIN, signal_handler);1.捕捉信号SIGRTMIN
	
 	//2.初始化sigevent变量
    sev.sigev_notify = SIGEV_SIGNAL;//定时器到期后发信号
    sev.sigev_signo = SIGRTMIN;//发送的信号为SIGRTMIN
    sev.sigev_value.sival_ptr = &timerid;//保存tiremid的指针
	
	//3.申请定时器，CLOCK_REALTIME实时计时
    if (timer_create(CLOCK_REALTIME, &sev, &timerid) == -1)
    {
    	perror ("timer_create");
    	exit (EXIT_FAILURE);
    }
	
	//5.初始化itimerspec变量
    its.it_value.tv_sec = 5;
    its.it_value.tv_nsec = 0;
    its.it_interval.tv_sec = 1;
    its.it_interval.tv_nsec = 0;
	
	//6.启动定时器
    if (timer_settime(timerid, 0, &its, NULL) == -1)
    {
    	perror ("timer_settime");
    	exit (EXIT_FAILURE);
    }

	while (1);
	//7.删除定时器
    timer_delete (timerid);
    exit(EXIT_SUCCESS);
}


```