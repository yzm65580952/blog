# 4.18 僵尸进程
## 父进程和子进程的关联
1. 在父进程中使用fork创建子进程、在调度器调度下分别调度运行
2. 子进程运行结束退出，内核释放相关资源
– 释放占用的内存、打开的文件
– 仍保留一定的信息：进程ID、退出状态、运行时间等
3. 父进程会调用wait/waitid 获取子进程的退出状态，释放最后的资源

## 什么是僵尸进程
1. 如果子进程exit退出，父进程没有调用wait获取子进程状态，那么子进程的相关资源仍然保存在系统中，这种进程称为僵尸进程
2. 僵尸进程会占用PID等资源，如果系统中存在大量僵尸进程，会影响fork子进程

## 进程的不同状态
R：task_running，可执行状态
S：task_interruptible，可中断的睡眠状态
D：task_uninterruptible，不可中断的睡眠状态
T：task_stopped、task_traced，暂停状态或跟踪状态
Z：task_dead、exit_zombie，退出状态，进程成为僵尸进程
X：task_dead、exit_dead，退出状态，进程即将被销毁

## 创建一个僵尸进程，并观察进程的状态
```c

#include <stdio.h>
#include <unistd.h>
#include <errno.h>
#include <stdlib.h>

int main (void)
{
	pid_t pid;
	pid = fork ();
	if (pid < 0)
	{
		perror ("fork");
		exit (-1);
	}
	else if (pid == 0)
	{
		printf ("child process, pid:%d ppid:%d\n", getpid (), getppid ());
		printf ("child process exit.\n");
		exit (0);
	}

	printf ("father process sleep 5 seconds\n");
	sleep (5);
	system ("ps -o pid,ppid,state,tty,command ");//发命令 
	printf ("father process exited.\n");

	return 0;
}
```
