# 4.8 等待子进程终止：wait
## wait()函数

1. 函数原型： pid_t wait(int *status);
2. 函数功能：等待子进程的终止及信息
3. 参数说明：子进程调用exit/_exit时的status
4. 返回值
– Wait调用成功，会返回已终止子进程的pid
– Wait调用失败，返回-1，设置errno值
– 若子进程没有终止，wait调用会阻塞父进程，直到子进程终止，子进程终止后，该调用立即返回

## wait 案例
```c

/************************************************
*      Filename: wait.c
*        Author: litao.wang
*    Bug Report: 3284757626@qq.com
*   Description: 
*        Create: 2019-03-13 11:00:40
* Last Modified: 2019-03-13 12:51:37
*************************************************/
#include <sys/types.h>
#include <unistd.h>
#include <stdio.h>
#include <stdlib.h>
#include <sys/wait.h>

int child_process (void)
{
	printf ("child process(pid:%d) start\n", getpid());
	;
	;
	printf ("child process exit\n");
	exit (100);
}
int main (void)
{
	int ret_from_fork;

	ret_from_fork = fork ();

	if (ret_from_fork > 0)//父进程
	{
			int wait_return_pid;

			printf ("father process(pid:%d) start\n", getpid());
			wait_return_pid = wait (NULL);
			//等待子进程结束，NULL不获取子进程的推出状态
			if (wait_return_pid == -1)
			{
				perror ("wait");
				exit (-1);
			}
			printf ("wait child process(pid:%d) exit succuss\n ", \
					 wait_return_pid);
			exit (0);
	}
	else if (ret_from_fork == 0)
		child_process ();
	else
	{
		perror ("fork");
		exit (-1);
	}
	return 0;
}
```

## 子程序的返回状态
定义在wait.h

## 通过宏来解析返回状态
WEXITSTATUS(status)：返回子进程的退出状态
WTERMSIG(status)：子进程因未捕捉的信号而终止，此宏返回true
WSTOPSIG(status)：子进程因信号暂停，此宏返回true 
WIFEXITED(status)：若子进程正常结束，返回true
WIFSIGNALED(status)：若通过信号杀掉子进程，此宏返回true
WIFSTOPPED(status)：若子进程因信号而停止，此宏返回true
WIFCONTINUED(status)：若子进程收到SIGCONT恢复运行，返回true

```c

/************************************************
*      Filename: wait_v2.c
*        Author: litao.wang
*    Bug Report: 3284757626@qq.com
*   Description: get wait return staus
*        Create: 2019-03-13 12:00:40
* Last Modified: 2019-03-13 13:33:32
*************************************************/
#include <sys/types.h>
#include <unistd.h>
#include <stdio.h>
#include <stdlib.h>
#include <sys/wait.h>

int child_process (void)
{
	printf ("child process(pid:%d) start\n", getpid());
	;
	;
	printf ("child process exit\n");
	exit (100);
}
int main (void)
{
	int ret_from_fork;
	int i;
	ret_from_fork = fork ();
	if (ret_from_fork > 0)//父进程
	{
			int wait_return_pid;
			int status = 0;
			printf ("father process(pid:%d) start\n", getpid ());
			wait_return_pid = wait (&status);//等待子进程退出，并获取退出状态
			if (wait_return_pid == -1)
				perror ("wait");
			if (WIFEXITED (status))//检测是否正常退出
				printf ("wait child process(pid:%d)return succuss, exit value:%d\n",\
						wait_return_pid, WEXITSTATUS (status));
			printf ("father process(pid:%d) exit\n",getpid ());
			exit (0);
	}
	else if (ret_from_fork == 0)
	{
		child_process ();
	}
	else
	{
		perror ("fork");
		return -1;
	}
	return 0;
}
```
## waitpid()函数
1. 函数原型： pid_t wait(pid_t pid, int *status, int options);
2. 函数功能：等待特定子进程的终止及信息
3. 参数说明：子进程调用exit/_exit时的status
4. 返回值
– Wait调用成功，会返回已终止子进程的pid
– Wait调用失败，返回-1，设置errno值
– 若子进程没有终止，wait调用会阻塞当前进程，直到子进程终止，子进程终止后，该调用立即返回

##  waitid()函数
1. System V 系统调用接口
2. 函数原型： int waitid( idtype_t idtype, id_t id, siginfo_t *infop, int options);
3. idtype：P_ALL等待任何子进程；P_PID、P_PGID等待特定进程/进程组