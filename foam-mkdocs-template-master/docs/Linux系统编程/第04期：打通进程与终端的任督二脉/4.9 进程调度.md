# 4.9 进程调度
## 调度器
1. 将有限的CPU资源分配给多个进程
2. 目的：最大化处理器效率，让多个进程同时运行、互不影响
3. 实现：
– 协同式：一个进程运行完自己的时间片，主动退出，CPU无权过问
– 抢占式：时间片到了或有更高优先级、调度器抢占CPU进行任务切换

## 进程分类
1. 处理器消耗型
渴望获取更多的CPU时间，并消耗掉调度器分配的全部时间片
常见例子：无限死循环、科学计算、影视特效渲染
2.  I/O消耗型
由于等待某种资源通常处于阻塞状态，不需要较长的时间片
常见例子：等待用户输入、GUI程序、文件读写I/O程序

## Linux调度策略
1. 对不同进程采取不同调度策略、实现多个调度器
完全公平调度CFS
实时进程调度RT
最终期限调度DL
IDLE类调度器、STOP类调度器
2.  不同进程由不同的调度器管理，彼此之间互不干扰
处理器消耗型进程：减少优先级、分配尽可能长的时间片
I/O消耗进程：增加优先级、增加实时性、增强用户体验
两者混合型

## 进程的nice值和优先级
1. $ nice -n 5 top
2. NI [-20,19] ：进程的NICE值，也叫静态优先级，nice值越小，抢占CPU能力越强，nice会影响进程的优先级
3. PRI[0,139]：进程的优先级，也叫动态优先级，值越小，优先级越高
4. 进程默认优先级：
#define DEFAULT_PRIO (MAX_RT_PRIO + NICE_WIDTH / 2)
5. 实时进程与非实时进程
实时进程：优先级[0,99]，采用实时进程的调度算法
非实时进程：优先级[100,139]，采用O1/CFS等调度算法
## 并发与并行区别
1. 并发：concurrency，CPU通过时间片轮转同时做多件事情
2. 并行：parallellism，很多事情在多个CPU上同时进行
3. 并发可以看做并行的一个“子集”
4. 一个应用程序
可以是并发的，但不是并行的
可以是并行的，但不是并发的
既是并发的，又是并行的
既不是并发的，又不是并行的

