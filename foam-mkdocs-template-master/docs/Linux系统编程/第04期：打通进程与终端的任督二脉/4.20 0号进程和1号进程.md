# 4.20 0号进程和1号进程
## Linux进程的起源
###   0号进程：
– 即idle进程，Linux内核启动后创建的第一个进程
– 唯一没有 通过fork或者kernel_thread创建的进程
###  1号进程：即init进程
– 由idle进程通过kernel_thread创建，在内核空间完成初始化后，加载init程
序，转变为用户空间的第一个进程
– Linux所有用户进程都是由init进程fork创建的，init是用户进程的“祖先”
– Init进程在系统启动后会转变为守护进程，托管孤儿进程，变为“孤儿院”
###  2号进程
– 即kthreadd内核线程，由kernel_thread创建，运行在内核空间
– 负责内核线程的调度和管理

## 从0到1
start_kernel：初始化内核各个组件，包括调度器，调用init_task
init_task，内核中所有进程、线程的task_struct的雏形
init_task调用kernel_thread创建内核init进程、kthreadd内核线程
内核初始化后，<font color=red >init_task最终演变为0号进程idle</font>
内核开始调度执行，当无进程运行时，会调度idle进程运行

## 从1到用户空间进程
1. Start_kernel->rest_init->kernel_thread(kernel_init, NULL, CLONE_FS);
2. 若用户通过<font color=red >init启动参数显式指定</font>，运行用户指定的程序
3. 若没指定：kernel_init->execve(/sbin/init) 运行init进程
– /sbin/init
– /etc/init
– /bin/init
– /bin/sh
4. 1号init进程从内核态转换为用户态，变为用户进程的“祖先”
5. 用户态init进程从/etc/inittab中完成各种初始化
– 初始化系统、启动各种服务
– 启动登录服务
– 用户态init进程接着执行/bin/bash启动shell进程
– 0号进程->init内核进程->1号init用户进程->getty进程->shell进程

##  Linux操作系统的init服务进程
### sysvinit
• 通过runlevel预定义运行模式：
– runlevel 3为命令行模式，5为图形界面模式，0是关机，6是重启。提供各种命令：reboot、shutdown等
– 运行位于/etc/rc*.d(一般链接到/etc/init.d)的脚本来启动各种系统服务
• 缺点：按脚本顺序启动服务，耗时较长，不适用消费电子
### upstart
• 基于事件驱动机制，动态开启、关闭相关服务
• 并行启动各种服务，启动速度快，适用于便携式设备
### systemd
• Linux桌面系统最新的初始化系统(init)、功能更强大
• 采用socket与总线激活式提高各个服务的并行运行性能
• 在Ubuntu等桌面操作系统中广泛使用

## 嵌入式中的init服务进程
### Linuxrc：在嵌入式系统中一般指定/linuxrc为init进程
### 设置bootargs：
– setenv bootargs ‘mem=64M console=ttyS0,115200 root=/dev/ram rw
init=/linuxrc’
### Linuxrc：存在于根文件系统的一个应用程序
– 在嵌入式Linux中一般是busybox，busybox是专为嵌入式开发的init应用程
序，提供了一整套的shell命令集：ls、cd、ps、pwd、rm等
– 负责系统启动前后的各种配置、引出用户界面(cmdline 或 GUI)


## start_kernel
```c
asmlinkage __visible void __init start_kernel(void)
{
        char *command_line;
        char *after_dashes;

        /*
         * Need to run as early as possible, to initialize the
         * lockdep hash:
         */
        lockdep_init();
        set_task_stack_end_magic(&init_task);
        smp_setup_processor_id();
        debug_objects_early_init();

        /*
         * Set up the the initial canary ASAP:
         */
        boot_init_stack_canary();

        cgroup_init_early();

        local_irq_disable();
        early_boot_irqs_disabled = true;

/*
 * Interrupts are still disabled. Do necessary setups, then
 * enable them
 */
        boot_cpu_init();
        page_address_init();
        pr_notice("%s", linux_banner);
        setup_arch(&command_line);
        mm_init_cpumask(&init_mm);
        setup_command_line(command_line);
        setup_nr_cpu_ids();
        setup_per_cpu_areas();
        smp_prepare_boot_cpu(); /* arch-specific boot-cpu hooks */

        build_all_zonelists(NULL, NULL);
        page_alloc_init();

        pr_notice("Kernel command line: %s\n", boot_command_line);
        /* parameters may set static keys */
        jump_label_init();
        parse_early_param();
        after_dashes = parse_args("Booting kernel",
                                  static_command_line, __start___param,
                                  __stop___param - __start___param,
                                  -1, -1, NULL, &unknown_bootoption);
        if (!IS_ERR_OR_NULL(after_dashes))
                parse_args("Setting init args", after_dashes, NULL, 0, -1, -1,
                           NULL, set_init_arg);

        /*
         * These use large bootmem allocations and must precede
         * kmem_cache_init()
         */
        setup_log_buf(0);
        pidhash_init();
        vfs_caches_init_early();
        sort_main_extable();
        trap_init();
        mm_init();

        /*
         * Set up the scheduler prior starting any interrupts (such as the
         * timer interrupt). Full topology setup happens at smp_init()
         * time - but meanwhile we still have a functioning scheduler.
         */
        sched_init();
        /*
         * Disable preemption - early bootup scheduling is extremely
         * fragile until we cpu_idle() for the first time.
         */
        preempt_disable();
        if (WARN(!irqs_disabled(),
                 "Interrupts were enabled *very* early, fixing it\n"))
                local_irq_disable();
        idr_init_cache();
        rcu_init();

        /* trace_printk() and trace points may be used after this */
        trace_init();

        context_tracking_init();
        radix_tree_init();
        /* init some links before init_ISA_irqs() */
        early_irq_init();
        init_IRQ();
        tick_init();
        rcu_init_nohz();
        init_timers();
        hrtimers_init();
        softirq_init();
        timekeeping_init();
        time_init();
        sched_clock_postinit();
        perf_event_init();
        profile_init();
        call_function_init();
        WARN(!irqs_disabled(), "Interrupts were enabled early\n");
        early_boot_irqs_disabled = false;
        local_irq_enable();

        kmem_cache_init_late();

        /*
         * HACK ALERT! This is early. We're enabling the console before
         * we've done PCI setups etc, and console_init() must be aware of
         * this. But we do want output early, in case something goes wrong.
         */
        console_init();
        if (panic_later)
                panic("Too many boot %s vars at `%s'", panic_later,
                      panic_param);

        lockdep_info();

        /*
         * Need to run this when irqs are enabled, because it wants
         * to self-test [hard/soft]-irqs on/off lock inversion bugs
         * too:
         */
        locking_selftest();

#ifdef CONFIG_BLK_DEV_INITRD
        if (initrd_start && !initrd_below_start_ok &&
            page_to_pfn(virt_to_page((void *)initrd_start)) < min_low_pfn) {
                pr_crit("initrd overwritten (0x%08lx < 0x%08lx) - disabling it.\n",
                    page_to_pfn(virt_to_page((void *)initrd_start)),
                    min_low_pfn);
                initrd_start = 0;
        }
#endif
        page_ext_init();
        debug_objects_mem_init();
        kmemleak_init();
        setup_per_cpu_pageset();
        numa_policy_init();
        if (late_time_init)
                late_time_init();
        sched_clock_init();
        calibrate_delay();
        pidmap_init();
        anon_vma_init();
        acpi_early_init();
#ifdef CONFIG_X86
        if (efi_enabled(EFI_RUNTIME_SERVICES))
                efi_enter_virtual_mode();
#endif
#ifdef CONFIG_X86_ESPFIX64
        /* Should be run before the first non-init thread is created */
        init_espfix_bsp();
#endif
        thread_info_cache_init();
        cred_init();
        fork_init();
        proc_caches_init();
        buffer_init();
        key_init();
        security_init();
        dbg_late_init();
        vfs_caches_init();
        signals_init();
        /* rootfs populating might need page-writeback */
        page_writeback_init();
        proc_root_init();
        nsfs_init();
        cpuset_init();
        cgroup_init();
        taskstats_init_early();
        delayacct_init();

        check_bugs();

        acpi_subsystem_init();
        sfi_init_late();

        if (efi_enabled(EFI_RUNTIME_SERVICES)) {
                efi_late_init();
                efi_free_boot_services();
        }

        ftrace_init();

        /* Do the rest non-__init'ed, we're now alive */
        rest_init();

        prevent_tail_call_optimization();
}
```