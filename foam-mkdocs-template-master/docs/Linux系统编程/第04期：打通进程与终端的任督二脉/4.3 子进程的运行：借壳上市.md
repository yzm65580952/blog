# 4.3 子进程的运行：借壳上市
## execvp函数
用二进制程序文件代替当前进程
1. 函数原型：int execvp (const char *file, char *const argv[]);
2. 功能说明：将当前进程的代码使用file程序文件代替并执行
3. 参数说明
file：要执行的程序名称
argv：要执行的程序文件的参数列表，<font color=red>参数列表以NULL指针为结束标记</font>
4. 返回值
成功：无返回值
失败：返回-1，并设置errno值

## 程序
运行程序
./a.out 
输入命令如
ls - a 
pwd
```c

/************************************************
*      Filename: execvp.c
*        Author: litao.wang
*    Bug Report: 3284757626@qq.com
*   Description: 
*        Create: 2019-03-11 00:24:53
* Last Modified: 2019-03-11 02:50:31
*************************************************/
#include <stdio.h>
#include <unistd.h>
#include <stdlib.h>

int child_process (int argc, char *argv[])
{
	char *arglist[argc];
	int i;
	int ret_from_exec;

	printf ("mini shell:#");//相当于一个shell

	for (i = 0; i < argc; i++)
		arglist[i] = argv[i+1];
	arglist[i] = NULL;	//参数列表以NULL指针为结束标记
	printf ("\n");
	//printf ("hello\n");
	ret_from_exec = execvp (arglist[0], arglist);
	if (ret_from_exec == -1)
	{
		perror ("execvp");
		exit (-1);
	}
	printf ("world\n");
	return 0;
}

int main (int argc, char *argv[])
{
	int ret_from_fork;

	ret_from_fork = fork ();

	if (ret_from_fork > 0)
	{
		printf ("father process\n");
		exit (0);
	}
	else if (ret_from_fork == 0)
	{
		child_process (argc, argv);
		exit (0);
	}
	else if (ret_from_fork == -1)
	{
		perror ("fork");
		exit (-1);
	}
	return 0;
}

```

 ## exec函数簇
 ```c
\#include <unistd.h>
int execl (const char *path, const char *arg, ...);
int execlp (const char *file, const char *arg, ...);
 int execle(const char *path, const char *arg, ...
 /*, (char *) NULL, char * const envp[] */);
int execv (const char *path, char *const argv[]);
int execvp (const char *file, char *const argv[]);
int execvpe (const char *file, char *const argv[], char *const envp[]);
```

## exec函数簇命名规则
L：参数以列表的形式提供
V：参数以数组(向量)的方式提供
E：为新进程提供新的环境变量，环境数组envp[]
P：支持文件名，系统会自动从当前路径以及环境变量“$PATH”所指出的路径中进行查找