# 7.12 线程同步：读写锁
## 基本概念
1. 互斥锁：同一时刻只允许一个线程读或写
2. 读写锁
– 允许多个读线程同时读
– 只允许一个线程写，写的时候会阻塞其它线程(包括读线程)
– 写优先级高于读

## 相关API函数
pthread_rwlock_t rwlock = PTHREAD_RWLOCK_INITIALIZER;
pthread_rwlock_init (pthread_rwlock_t *restrict rwlock,const pthread_rwlockattr_t *restrict attr);
int pthread_rwlock_rdlock (pthread_rwlock_t *rwlock);
int pthread_rwlock_wrlock (pthread_rwlock_t *rwlock);
int pthread_rwlock_tryrdlock (pthread_rwlock_t *rwlock);
int pthread_rwlock_trywrlock (pthread_rwlock_t *rwlock);
int pthread_rwlock_unlock (pthread_rwlock_t *rwlock);
nt pthread_rwlock_destroy (pthread_rwlock_t *rwlock);
## demo

```c
#include <stdio.h>
#include <pthread.h>
#include <unistd.h>

int cake_count = 0;
pthread_rwlock_t rwlock;

void *write_thread (void *arg)
{
    static int id = 0;
    int i = ++id;
    int produce  = *(int*)arg;
    while (1)
    {
        pthread_rwlock_wrlock (&rwlock);	//打开读写锁
        cake_count += produce;
        printf ("produce thread %d: cake_count = %d\n", i, cake_count);
        pthread_rwlock_unlock (&rwlock);//关闭读写锁
        sleep (1);
    }
    printf ("produce thread: exit\n");
    pthread_exit (NULL);
}

void *read_thread (void *arg)
{
    static int id = 0;
    int i = ++id;
    int consume_unit = *(int*)arg;
    while (1)
    {
        pthread_rwlock_rdlock (&rwlock);//打开读写锁
        printf ("consume thread %d  cake_count = %d\n", i, cake_count);
        pthread_rwlock_unlock (&rwlock);//关闭读写锁
        sleep (1);
    }
    printf ("consume thread %d: exit\n", i);
    pthread_exit (NULL);
}

int main (void)
{
    pthread_t produce_tid1, produce_tid2;
    pthread_t consume_tid1, consume_tid2, consume_tid3;
    int produce1 = 10; // produce per second
    int produce2 = 20;
    int consume1 = 5;  // consume per second
    int consume2 = 10;
    int consume3 = 15;

    pthread_rwlock_init (&rwlock, NULL);//1.初始化读写锁
	//2.创建生产者线程
    pthread_create (&produce_tid1, NULL, write_thread, (void *) &produce1);
    pthread_create (&produce_tid2, NULL, write_thread, (void *) &produce2);
	//3.创建消费者线程 只读不修改
    pthread_create (&consume_tid1, NULL, read_thread, (void *) &consume1);
    pthread_create (&consume_tid2, NULL, read_thread, (void *) &consume2);
    pthread_create (&consume_tid3, NULL, read_thread, (void *) &consume3);
	
	//4.等待线程退出
    pthread_join (produce_tid1, NULL);
    pthread_join (produce_tid2, NULL);
    pthread_join (consume_tid1, NULL);
    pthread_join (consume_tid2, NULL);
    pthread_join (consume_tid3, NULL);
    
    pthread_rwlock_destroy (&rwlock);//.销毁读写锁
    printf ("main thread: exit\n");
    return 0;
}

```