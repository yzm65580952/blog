# 7.10 线程同步：条件变量(上)
 ## 基本概念
1. 互斥锁缺陷：
– 不断加锁解锁、查询满足条件，开销很大
– 加锁开销：用户态-内核态-用户态，阻塞在内核态
– 解锁开销：用户态-内核态-用户态，唤醒等待线程
2. 条件变量
– 互斥锁(mutex)搭配使用，允许线程阻塞，等待条件满足的信号
3. 优势：
– 将互斥锁和条件变量绑定
– 省去了不断加锁解锁的开销
– 可以使用广播(broadcast)唤醒所有绑定到该条件变量的线程
## 相关API函数
pthread_cond_t cond = PTHREAD_COND_INITIALIZER;
int pthread_cond_init (pthread_cond_t *cond, pthread_condattr_t *cond_attr);
int pthread_cond_wait (pthread_cond_t *cond, pthread_mutex_t *mutex );
int pthread_cond_signal (pthread_cond_t *cond);
int pthread_cond_broadcast (pthread_cond_t *cond);
int pthread_cond_timedwait (pthread_cond_t *cond, pthread_mutex_t *mutex,const struct timespec *abstime);
int pthread_cond_destroy (pthread_cond_t *cond);

## demo
```c
#include <stdio.h>
#include <pthread.h>
#include <unistd.h>

int current_count = 0;
pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER;
pthread_cond_t  cond  = PTHREAD_COND_INITIALIZER;

static void * produce_thread (void *arg)
{
    int count_init = *(int*)arg;
    current_count  = count_init;
    while (1)
    {
        pthread_mutex_lock (&mutex);//加锁
        current_count++;
        printf ("produce thread: current_count = %d\n", current_count);
        if (current_count % 10 == 0)
            pthread_cond_signal (&cond);//发送条件变量，单播
        pthread_mutex_unlock (&mutex);
        sleep (1);
    }
    printf ("produce thread: exit\n");
    pthread_exit (NULL);
}
static void *consume_thread (void *arg)
{
    int consume_unit = *(int*)arg;
    while (1)
    {
        pthread_mutex_lock (&mutex);		//加锁
        pthread_cond_wait (&cond, &mutex);	//释放掉互斥锁，等带条件变量cond
        current_count -= 10;
        printf ("consume thread has consume %d\n", consume_unit);
        pthread_mutex_unlock (&mutex);//释放锁
        sleep (1);
    }
    printf ("consume thread: exit\n");
    pthread_exit (NULL);
}

int main (void)
{
    pthread_t tid1, tid2;
    pthread_mutex_init (&mutex, NULL);//初始化互斥锁
    
    int arg1 = 5;
    int arg2 = 10;
    pthread_create (&tid1, NULL, produce_thread, (void *) &arg1);
    pthread_create (&tid2, NULL, consume_thread, (void *) &arg2);
    pthread_join (tid1, NULL);//等待线程结束并回收资源
    pthread_join (tid2, NULL);
    
    pthread_mutex_destroy (&mutex);
    pthread_cond_destroy (&cond);
    
    printf ("main thread: exit\n");
    return 0;
}
```