# 7.9 线程同步：互斥锁
## 竞争访问
全局变量
缓冲区
三室一厅卫生间

## 相关API函数
int pthread_mutex_init(pthread_mutex_t *mutex, constpthread_mutexattr_t *mutexattr);
int pthread_mutex_lock(pthread_mutex_t *mutex);
int pthread_mutex_trylock(pthread_mutex_t *mutex);
int pthread_mutex_unlock(pthread_mutex_t *mutex);
int pthread_mutex_destroy(pthread_mutex_t *mutex);

## demo
```c
#include <stdio.h>
#include <pthread.h>
#include <unistd.h>

int cake_count = 0;		//全局变量，蛋糕个数
pthread_mutex_t mutex;	//锁变量

static void *produce_thread (void *arg)	//生产者线程
{
    cake_count = *(int*)arg;
    while (1)
    {
        pthread_mutex_lock (&mutex);	//加锁
        cake_count += 1;
        printf ("produce thread: cake_count = %d\n", cake_count);//生产
        pthread_mutex_unlock (&mutex);//解锁
        sleep (3);
    }
    printf ("sub thread1: exit\n");
    pthread_exit (NULL);
}
static void *consume_thread (void *arg)//消费者线程
{
    int consume_unit = *(int*)arg;
    while (1)
    {
        pthread_mutex_lock (&mutex);//加锁
        if (cake_count == 0)
        {
            pthread_mutex_unlock (&mutex);//非正常退出也要解锁
            continue;
        }
        cake_count -= consume_unit;//消费
        printf ("consume thread consume 1: cake_count = %d\n", cake_count);
        pthread_mutex_unlock (&mutex);//解锁
        sleep (1);
    }
    printf ("sub thread2: exit\n");
    pthread_exit (NULL);
}

int main (void)
{
    pthread_t tid1, tid2;

    pthread_mutex_init (&mutex, NULL);//1.申请锁

    int arg1 = 10;
    int arg2 = 1;
    pthread_create (&tid1, NULL, produce_thread, (void *) &arg1);//2.运行生产者线程
    pthread_create (&tid2, NULL, consume_thread, (void *) &arg2);//3.运行消费者线程
    pthread_join (tid1, NULL);//4.回收线程
    pthread_join (tid2, NULL);
    
    pthread_mutex_destroy (&mutex);//5.销毁锁
    printf ("main thread: exit\n");
    return 0;
}

```
