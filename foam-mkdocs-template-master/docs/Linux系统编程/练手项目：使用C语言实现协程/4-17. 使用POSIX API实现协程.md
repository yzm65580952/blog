# 4-17. 使用POSIX API实现协程
ctx.h
```c
#ifndef __CTX_H__
#define __CTX_H__


int coroutine_create (void (*fn)(void *), void *args, unsigned int size); 
int coroutine_yield (void);
int coroutine_resume (int co_id);
    

#endif

```
ctx.c
```c
#include <unistd.h>
#include <ucontext.h>
#include <stdlib.h>

#define STACK_SIZE (1024 * 64)

struct coroutine	//协程结构体
{
    void (*func) (void *);
    void *args;	//定义一个协程的参数的指针
    char *stack;//定义为指针，方便使用动态
    ucontext_t ctx;
};

ucontext_t ctx_main;
struct coroutine coroutine_slots[8];	//保存协程信息的数组
int id_num = 0;
int current_id = 0;	//全局变量保存当前正在运行的协程id

void coroutine_start (void)
{
	//获取当前运行的携程的结构体
    struct coroutine *t = &coroutine_slots[current_id];
    t->func (t->args);//运行携程函数，并传入参数
}

int coroutine_create (void (*fn)(void *), void *arg, unsigned int size) 
{
    struct coroutine *rt = &coroutine_slots[id_num];//协程创建在数组
    getcontext (&(rt->ctx));
    current_id = id_num;	//current_id=函数指针数组的下标
    rt->func = fn;
    rt->args = arg;
    int real_size;
	
    if (size == 0)		//指定协程栈的大小
        real_size = STACK_SIZE;
    else
        real_size = size;
		
    rt->stack = (char *) malloc (real_size);//申请堆内存，动态
    rt->ctx.uc_stack.ss_sp    = rt->stack;//堆栈指针
    rt->ctx.uc_stack.ss_size  = real_size;//栈的大小
    rt->ctx.uc_stack.ss_flags = 0;
    rt->ctx.uc_link  = &ctx_main;	//协程的后继
	
	
    makecontext (&(rt->ctx), coroutine_start, 0);//保存上下文
    swapcontext (&ctx_main, &(rt->ctx));//交换函数，回到main
    return id_num++;	//函数指针数组index++
}

int coroutine_yield (void)//让出cpu，回到main
{
    struct coroutine *t = &coroutine_slots[current_id];
    swapcontext (&(t->ctx), &ctx_main);
}

int coroutine_resume (int co_id)//从mian，切换到协程
{
    struct coroutine *t = &coroutine_slots[co_id];
    current_id = co_id;	//保存当前协程id到全局变量
    swapcontext (&ctx_main, &(t->ctx));
    free (t->stack);//携程使用完毕释放堆内存
    t->stack = NULL;
}


```
main.c
```c
#include <stdio.h>
#include "ctx.h"

#define MY_SIZE (1024 * 32)

void coroutine_read (void *args)
{
    puts ("coroutine_read start");
    coroutine_yield ();//协程退出
    int data = *(char *) args;
    printf ("read coroutine read data: %d\n", data);
    puts ("coroutine_read exit");
}

void coroutine_write (void *args)
{
    puts ("coroutine_write start");
    *(char *)args = 100;
    puts (" write coroutine write data success");
    coroutine_yield ();
    puts ("coroutine_write exit");
}

int main (void)
{
    int rd_id;
    int wr_id;
    char buf[512];
	//创建协程，协程栈的大小指定为0，使用默认大小STACK_SIZE
	//读协程coroutine_read退出，等待写协程coroutine_write
	//写协程coroutine_write写buf
    rd_id = coroutine_create (coroutine_read, buf, 0);
    wr_id = coroutine_create (coroutine_write, buf, 0);
    coroutine_resume (rd_id);//切换回读协程
    coroutine_resume (wr_id);//切换回写协程
    puts ("main exit");
    return 0;
}

```
