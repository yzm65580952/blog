# 5.10 system V 消息队列
## System V 消息队列通信方法
1. 支持不同进程之间以消息(message)的形式交换数据。
2. 发送者
获取消息队列的ID(IPC标识符)
将数据放入一个带有标识的消息结构体，发送到消息队列
3. 接收者
获取消息队列的ID
将指定标识的消息从消息队列中读出，然后进一步后续处理

## 编程接口
 1. key_t ftok (const char *pathname, int proj_id);
2. int msgget(key_t key, int msgflg);
– 创建或打开一个消息队列
– 首先从既有消息队列中搜索与指定key对应的队列，返回该对象的标识符
– 若没找到，msgflg指定了IPC_CREAT，则创建一个队列，并返回IPC标识符
3. int msgsnd (int msqid, const void *msgp, size_t msgsz, int msgflg);
– 发送消息到消息队列
4. ssize_t msgrcv(int msqid, void *msgp, size_t msgsz, long msgtyp, int msgflg);
– 从消息队列中接收信息
5. int msgctl(int msqid, int cmd, struct msqid_ds *buf);
– IPC_STAT：获取消息队列的属性信息
– IPC_SET：设置消息队列的属性
– IPC_RMID：删除消息队列
## 内核实现：消息队列模型
1. 相关数据结构：/usr/include/linux/msg.h、/ipc/msg.c
2. msqid_ds：标识整个消息队列的基本情况：消息队列权限、所有者、操作权限，和2个指针，分别指向消息队列中的第一和最后一个消息
3. msg：整个消息队列的主体，一个消息队列有若干个消息，每个消息数据结构的基本信息包括消息类型、消息大小、消息内容指针和下一个消息数据结构位置
4. 消息队列是消息的链表，存储在内核中，由消息队列标识符标识。
5. IPC标识符：消息队列的ID
6. 消息队列中消息的个数是有限制的


## 消息结构体

```c
  struct msgbuf {
      long mtype;/* message type, must be > 0 */
      data_t  data;/* message data */
	  //data_t  data; 是自己定义的
  };
```

msgsnd (int msqid, const void *msgp, size_t msgsz, int msgflg);
msgsz代表的是消息的大小
msgsz = sizeof(msgbuf.data)
##  打印消息队列
ipcs	
ipcs -q

## 源代码
msg_snd.c
```c
/************************************************
*      Filename: msg_snd.c
*        Author: litao.wang
*    Bug Report: 3284757626@qq.com
*   Description: 
*        Create: 2019-07-14 16:03:42
* Last Modified: 2019-07-19 12:12:59
*************************************************/
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>
#include <errno.h>
#include <sys/types.h>
#include <sys/ipc.h>
#include <sys/msg.h>

#define MSG_TYPE1 1	//定义消息的类型
#define MSG_TYPE2 2

struct msgbuf		//定义消息的结构体
{
	long mtype;
	char mtext[80];
};

int main (void)
{
//	key_t key = ftok (".", 510);	//生成一个消息队列的key
	key_t key = 12345;
	int msg_id = msgget (key, IPC_CREAT | 0666);	
	//打开消息队列，若不存在则创建
	
	struct msgbuf msg;				//封装消息
	memset (&msg, 0, sizeof(msg));
	msg.mtype = MSG_TYPE2;		//指定消息类型为MSG_TYPE2
	strncpy (msg.mtext, "hello world\n", 80);

	if (msgsnd (msg_id, (void *)&msg,  \
                strlen (msg.mtext), 0) == -1)	//发送消息
	{
		perror ("msgsnd");
		exit (EXIT_FAILURE);
	}

	return 0;
}

```
msg_rcv.c

```c
/************************************************
*      Filename: msg_rcv.c
*        Author: litao.wang
*    Bug Report: 3284757626@qq.com
*   Description: 
*        Create: 2019-07-14 15:52:50
* Last Modified: 2019-07-19 12:23:56
*************************************************/
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>
#include <errno.h>
#include <signal.h>
#include <sys/types.h>
#include <sys/ipc.h>
#include <sys/msg.h>

#define MSG_TYPE1 1
#define MSG_TYPE2 2

struct msgbuf
{
	long mtype;
	char mtext[80];
};

int main (int argc, char *argv[])
{
//	key_t key = ftok (".", 510);
	key_t key = 12345;
	int msg_id = msgget (key, IPC_CREAT | 0666);
	//打开消息队列，若不存在则创建

	struct msgbuf msg;
	memset (&msg, 0, sizeof(msg));
	if (msgrcv (msg_id, (void *)&msg,  \
                sizeof(msg.mtext), MSG_TYPE2, 0) == -1)//接收类型为MSG_TYPE2的消息
	{
		perror ("msgrcv");
		exit (EXIT_FAILURE);
	}
	printf ("%s", msg.mtext);
	msgctl (msg_id, IPC_RMID, NULL);	//IPC_RMID 删除消息队列

	return 0;
}
```

## 内核实现：消息队列模型
1. 相关数据结构：/usr/include/linux/msg.h、/ipc/msg.c
2. msqid_ds：标识整个消息队列的基本情况：消息队列权限、所有者、
操作权限，和2个指针，分别指向消息队列中的第一和最后一个消息
3. msg：整个消息队列的主体，一个消息队列有若干个消息，每个消息
数据结构的基本信息包括消息类型、消息大小、消息内容指针和下一
个消息数据结构位置
4. 消息队列是消息的链表，存储在内核中，由消息队列标识符标识。
5. IPC标识符：消息队列的ID


### 打印消息队列结构体
```c
/************************************************
*      Filename: msg_snd.c
*        Author: litao.wang
*    Bug Report: 3284757626@qq.com
*   Description: 
*        Create: 2019-07-14 16:03:42
* Last Modified: 2019-07-19 11:50:15
*************************************************/
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>
#include <errno.h>
#include <sys/types.h>
#include <sys/ipc.h>
#include <sys/msg.h>

#define handle_error(msg) \
    {perror(msg);exit(EXIT_FAILURE);}

int main (void)
{
//	key_t key = ftok (".", 510);
	key_t key = 12345;
	int msg_id = msgget (key, IPC_CREAT | 0666);

	struct msqid_ds info;
	if (msgctl (msg_id, IPC_STAT, &info) == -1)	//设置消息队列
        handle_error("msgctl");
	printf ("uid:%d, gid:%d, cuid:%d, cgid:%d\n", info.msg_perm.uid, \
			info.msg_perm.gid, info.msg_perm.cuid, info.msg_perm.cgid);
	printf ("mode:%03o, cbytes:%lu, qnum:%lu, qbytes:%lu\n", \
			info.msg_perm.mode & 0777, info.msg_cbytes,  \
			info.msg_qnum, info.msg_qbytes);

	info.msg_qbytes = 16380;
	if (msgctl (msg_id, IPC_SET, &info) == -1)
        handle_error("msgctl");
	if (msgctl (msg_id, IPC_STAT, &info) == -1)
        handle_error("msgctl");
	
    printf ("mode:%03o, cbytes:%lu, qnum:%lu, qbytes:%lu\n", \
			info.msg_perm.mode & 0777, info.msg_cbytes,  \
			info.msg_qnum, info.msg_qbytes);

	return 0;
}
```