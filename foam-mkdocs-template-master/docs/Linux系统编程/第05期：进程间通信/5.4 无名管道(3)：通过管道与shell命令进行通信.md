# 5.4 无名管道(3)：通过管道与shell命令进行通信
## popen函数

1. FILE *popen(const char *command, const char *type);
2. 创建一个管道，并<font color=red>创建一个子进程来执行shell，shell会创建一个子进程来执行command</font>
3. 将<font color=red>父子进程的输入/输出重定向到管道</font>，建立一个单向的数据流
4. 返回一个fp文件指针给父进程，<font color=red>父进程可根据fp对管道进行读写</font>
5. 向管道中读数据：读命令的标准输出
6. 向管道中写数据：写入该命令的标准输入

## 读模式调用popen
fp = popen (command, “r”);
popen函数创建子进程执行command，创建管道
子进程的标准输出写入到管道，被调用popen的父进程读取。
父进程通过对popen返回的fp指针读管道，获取执行命令的输出

## 写模式调用popen
fp = popen (command, “w”);
popen函数创建子进程执行command，创建管道
调用popen的父进程，通过fp进行对管道进行写操作
写入的内容通过管道传给子进程，作为子进程的输入

## 程序
```c
/************************************************
*      Filename: popen.c
*        Author: litao.wang
*    Bug Report: 3284757626@qq.com
*   Description: 
*        Create: 2019-06-20 07:17:24
* Last Modified: 2019-07-18 10:22:25
*************************************************/
#include <stdio.h>
#include <unistd.h>
#include <string.h>
#include <stdlib.h>

#define handle_error(msg) \
    {perror(msg);exit(EXIT_FAILURE);}

int popen_read (void)
{
	FILE *fp;
	char buf[1024] = {0};

	fp = popen ("cat popen.c", "r");
	if (fp == NULL)
        handle_error("popen");
	fread (buf, 1, 1024, fp);
    printf ("%s\n", buf);
	pclose (fp);
	return 0;
}

int popen_write (void)
{
	FILE *fp = NULL;
	char buf[128] = {0};
	
	fp = popen ("cat > write.log", "w");	//写到write.log
	if (fp == NULL)
	    handle_error("popen");
	fwrite ("hello world!\n", 1, sizeof ("hello world!"), fp);
	//具体写的内容
	pclose (fp);

	return 0;
}

int main (void)
{
	popen_read ();
	popen_write ();
	return 0;
}

```