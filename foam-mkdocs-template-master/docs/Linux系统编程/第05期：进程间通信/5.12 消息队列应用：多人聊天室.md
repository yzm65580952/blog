# 5.12 消息队列应用：多人聊天室
## 多用户本地聊天室
支持多人同时聊天(3人以上、可以修改程序设置)
每个用户端进程以ID登录，ID作为服务端要发送的消息类型
服务端实现消息的广播转发功能

## 消息队列与FIFO比较
### 引用方式
用来标识消息队列的是一个key，而不是普通文件所用的pathname
用来引用消息队列的句柄是一个由msgget()调用返回的标识符。
这些标识符类似于普通文件I/O通过open返回的文件描述符。
### 传输的数据
FIFO发送的数据是流式数据、raw数据
通过消息队列进行的通信是面向消息的
除了包含数据之外，每条消息还有一个用整数表示的类型。
### 消息队列比FIFO优越的地方
消息队列双方通过消息通信，无需花费精力从字节流中解析出完整信息
每条消息都有type字段，read进程可通过消息类型选择自己感兴趣的消息

## 消息队列的优点
1. 降低系统耦合：
– 生产者-消费者模式，自助餐模式，多个读写进程通过容器建立联系、互
不影响，实现解耦
– 消息是跟平台和语言无关的。
2. 提速系统性能：
– 非核心流程异步化，非阻塞模式节省时间，不需要双方同时在线
3. 广播：
– 一个消息可以发送给多个进程，只需要发送到队列就可以了
4. 削峰：
– 生产者-消费者的负载平衡、秒杀活动
## 消息队列的缺陷
1. 效率低：“代理人”通信机制
2. 内核：为使用者分配内存、检查边界、设置阻塞、权限监控
3. 消息队列的的总数、消息的大小、单个队列的容量是有限制的
– 注：Linux没有限制
– MSGMNI：系统中所能创建的消息队列标识符
– MSGMAX：单条消息中最多可写入的字节数
– MSGMNB：一个消息队列中一次最多保存的字节数（mtext）
– MSGTQL：系统中所有消息队列所能存放的消息总数
– MSGPOOL：消息队列中用于存放数据的缓冲区的大小
4. 使用标识符而不是文件描述符来引用，使用键而不是文件名来标识消息队列，使用复杂
5. 消息队列是无连接的，内核不会像对待管道、FIFO、socket那样维护引用队列的进程数
## 代码
server.c
```c
/************************************************
*      Filename: server.c
*        Author: litao.wang
*    Bug Report: 3284757626@qq.com
*   Description: 
*        Create: 2019-07-14 16:03:42
* Last Modified: 2019-07-19 22:44:46
*************************************************/
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>
#include <errno.h>
#include <sys/types.h>
#include <sys/ipc.h>
#include <sys/msg.h>


#define TO_SERVER_MSGTYPE 1000	//1.定义消息类型
#define CLIENT_NUMBER 3		//支持的最大客户端数

struct msgbuf			//2.定义消息结构体
{
	long mtype;
	int client_id;
	char mtext[80];
};

int main (void)
{
//	key_t key = ftok ("./", 512);	//3.定义key
	key_t key = 512;
	int msg_id = msgget (key, IPC_CREAT | 0666);//4.注册消息队列
	struct msgbuf msg;

    while (1)
	{
	    memset (&msg, 0, sizeof(msg));
		if (msgrcv (msg_id, (void *)&msg, sizeof(msg.mtext), \
					TO_SERVER_MSGTYPE, 0) == -1)
					//5.接收消息
		{
			perror ("msgrcv");
			exit (EXIT_FAILURE);
		}
		else
		{
			for (int i = 1; i <= CLIENT_NUMBER; i++)
			{
				if (i == msg.client_id)
					continue;	//不需转发发给发送者
				else
				{
					msg.mtype = i;
					msgsnd (msg_id, &msg, 80, 0);//6.转发消息到别的客户端
				}
			}
		}
		printf ("server: %s\n", msg.mtext);
	}
	msgctl (msg_id, IPC_RMID, NULL);
	return 0;
}

```
client.c
```c
/************************************************
*      Filename: client.c
*        Author: litao.wang
*    Bug Report: 3284757626@qq.com
*   Description: 
*        Create: 2019-07-14 15:52:50
* Last Modified: 2019-07-19 23:06:21
*************************************************/
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>
#include <errno.h>
#include <signal.h>
#include <sys/types.h>
#include <sys/ipc.h>
#include <sys/msg.h>

#define handle_error(msg) \
    {perror(msg);exit(EXIT_FAILURE);}

#define TO_SERVER_MSGTYPE 1000//1.定义消息类型，消息统一由server转发

struct msgbuf				//2.定义消息结构体
{
	long mtype;	//标识是哪个客户端发的消息
	int client_id;
	char mtext[80];
};

int main (void)
{
//	key_t key = ftok ("./", 512);
	key_t key = 512;
	int msg_id = msgget (key, IPC_CREAT | 0666);//3.打开消息队列

	struct msgbuf msg_snd, msg_rcv;

	printf ("input guest ID:");//4.键盘输入客户端的id
	int client_id;
	scanf ("%d", &client_id);
	printf ("client_id: %d\n", client_id);

	int ret_from_fork;
	ret_from_fork = fork ();//5.创建子进程
	if (ret_from_fork == -1)
        handle_error("fork")	
	else if (ret_from_fork == 0)//子进程
	{
		while (1)
		{
			gets (msg_snd.mtext);				//6.填写消息结构体
			msg_snd.mtype = TO_SERVER_MSGTYPE;
			msg_snd.client_id = client_id;
			msgsnd (msg_id, &msg_snd, 80, 0);	//7.发送消息
		}
	}
	else	//父进程
	{
		while (1)
		{
			memset (&msg_rcv, 0, sizeof(msg_rcv));
			if (msgrcv (msg_id, (void *)&msg_rcv, \
                        sizeof(msg_rcv.mtext), client_id, 0) == -1)
			    handle_error("msg_rcv")
			else
				printf ("client%d: %s\n", msg_rcv.client_id, msg_rcv.mtext);
		}
	}
	return 0;
}

```