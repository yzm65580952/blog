# 5.21 POSIX 信号量
## 相关的API
sem_t *sem_open (const char *name, int oflag);
sem_t *sem_open (const char *name, int oflag,mode_t mode,unsigned int value);
int sem_close (sem_t *sem);
int sem_post (sem_t *sem);
int sem_wait (sem_t *sem);
int sem_trywait (sem_t *sem);
int sem_timedwait (sem_t *sem, const struct timespec *abs_timeout);
int sem_unlink (const char *name);
int sem_getvalue (sem_t *sem, int *sval);

## 使用指南
1. 包含头文件：#include <semaphore.h>
2. 编译时要指定：-lpthread
3. Pthread：
– POSIX threads，操作线程的API标准
– 适用于 Unix、Linux、Mac OS

## 代码
sem_demo.c
```c
/************************************************
*      Filename: sem_demo.c
*        Author: litao.wang
*    Bug Report: 3284757626@qq.com
*   Description: 
*        Create: 2019-07-01 22:03:27
* Last Modified: 2019-07-22 14:31:26
*************************************************/
#include <stdio.h>
#include <fcntl.h>
#include <sys/stat.h>
#include <semaphore.h>
#include <errno.h>
#include <stdlib.h>
#include <unistd.h>

int main (void)
{
	unsigned int sem_value = 4;	//1.设置信号量的值设
	sem_t *sem = sem_open ("posix_sem", O_RDWR | O_CREAT | O_EXCL, 0777, sem_value);
	//2.打开一个信号量，并赋值 会在/dev/shm/创建
	if (sem == SEM_FAILED)
	{
		perror ("sem_open");
		exit (EXIT_FAILURE);
	}
	if (sem_getvalue (sem, &sem_value) != -1)		//3.获取信号量的值
		printf ("the sem value: %d\n", sem_value);

	sem_wait (sem);	//4.信号量-1
	sem_wait (sem);
	sem_wait (sem);
	sem_wait (sem);
//	sem_wait (sem);
	sem_trywait (sem);		//不会减到负数，不会挂起
	if (sem_getvalue (sem, &sem_value) != -1)		//5.获取信号量，并打印
		printf ("the sem value: %d\n", sem_value);
	sem_post (sem);
	sem_post (sem);//6.信号量+1
	sem_post (sem);
	sem_post (sem);
	sem_post (sem);
	sem_post (sem);
	if (sem_getvalue (sem, &sem_value) != -1)		//7.获取信号量，并打印
		printf ("the sem value: %d\n", sem_value);

	if (sem_close (sem) != -1)						//8.关闭信号量
		printf ("sem close posix_sem success\n");
	
	printf ("wait for sem_unlink, 10s\n");
	sleep (10);

	if (sem_unlink ("posix_sem") != -1)				//7.删除信号量
		printf ("sem_unlink posix_sem success\n");

	return 0;
}

```

## 两个进程使用同一个信号量同步
sem_sync.c
子进程1s 减一次
父进程2s 加一次
两个进程同步
```c
/************************************************
*      Filename: sem_sync.c
*        Author: litao.wang
*    Bug Report: 3284757626@qq.com
*   Description: 
*        Create: 2019-07-01 10:39:21
* Last Modified: 2019-07-22 14:30:47
*************************************************/
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <semaphore.h>
#include <fcntl.h>
#include <pthread.h>

#define SEM_NAME "/posix_sem_operation"

int main (void)
{
	int i = 0;
	int j = 0;
	int ret_fork;
	int sem_val = 0;
    sem_t *sem;
	sem = sem_open (SEM_NAME, O_CREAT, 0666, 1);//1.打开信号量

	ret_fork = fork ();		//2.创建子进程
	if (ret_fork == -1)
	{
		perror ("fork");
		sem_close (sem);
		sem_unlink (SEM_NAME);
		exit (EXIT_FAILURE);
	}
	if (ret_fork == 0)
	{
		while (i++ < 10)
		{
		//	sem_trywait (sem);
            sem_wait (sem);		//3.子进程信号量-1操作
			sem_getvalue (sem, &sem_val);
			printf ("child process: sem value = %d\n", sem_val);
			sleep (1);
		}
        exit (EXIT_SUCCESS);
	}
	else if (ret_fork > 0)
	{
		while (j++ < 10)
		{
			sem_post (sem);
			sem_getvalue (sem, &sem_val);	//4.父进程信号量+1操作
			printf ("parent process: sem value = %d\n", sem_val);
			sleep (2);
		}
	}

	sem_close (sem);		//5.关闭信号量
	sem_unlink (SEM_NAME);	//6.删除信号量
	return 0;
}
```

## 非血缘关系的两个进程同步
sem_wait.c
```c
/************************************************
*      Filename: sem_wait.c
*        Author: litao.wang
*    Bug Report: 3284757626@qq.com
*   Description: 
*        Create: 2019-07-01 22:03:27
* Last Modified: 2019-07-22 14:37:31
*************************************************/
#include <stdio.h>
#include <fcntl.h>
#include <sys/stat.h>
#include <semaphore.h>
#include <errno.h>
#include <stdlib.h>
#include <unistd.h>

int main (void)
{
	char *name = "/posix_sem";
	unsigned int sem_value = 4;
	sem_t *sem = sem_open (name, O_RDWR | O_CREAT, 0777, sem_value);
	if (sem == SEM_FAILED)
	{
		perror ("sem_open");
		exit (EXIT_FAILURE);
	}
	printf ("sem_open %s success\n", name);

	while (1)
	{
		if (sem_wait (sem) == -1)
		{
			perror ("sem_wait");
			exit (EXIT_FAILURE);
		}
		if (sem_getvalue (sem, &sem_value) != -1)
			printf ("wait process: sem value=%d\n", sem_value);
		sleep (1);
	}

	sleep (10);
    sem_close (sem);
	if (sem_unlink (name) != -1)
		printf ("sem_unlink %s success\n", name);

	return 0;
}
```
sem_post.c

```c
/************************************************
*      Filename: sem_post.c
*        Author: litao.wang
*    Bug Report: 3284757626@qq.com
*   Description: 
*        Create: 2019-07-03 12:44:35
* Last Modified: 2019-07-22 14:38:25
*************************************************/
#include <stdio.h>
#include <fcntl.h>
#include <sys/stat.h>
#include <semaphore.h>
#include <errno.h>
#include <stdlib.h>
#include <unistd.h>

int main (void)
{
	char *name = "/posix_sem";
	unsigned int sem_value = 4;
	sem_t *sem = sem_open (name, O_RDWR | O_CREAT, 0777, sem_value);
	if (sem == SEM_FAILED)
	{
		perror ("sem_open");
		exit (EXIT_FAILURE);
	}
	printf ("sem_open %s success\n", name);

	while (1)
	{
		if (sem_post (sem) == -1)
		{
			perror ("sem_post");
			return -1;
		}
		if (sem_getvalue (sem, &sem_value) != -1)
			printf ("post process: sem value=%d\n", sem_value);
		sleep (5);
	}

	sleep (10);
    
	if (sem_unlink (name) != -1)
		printf ("sem_unlink %s success\n", name);

	return 0;
}

```