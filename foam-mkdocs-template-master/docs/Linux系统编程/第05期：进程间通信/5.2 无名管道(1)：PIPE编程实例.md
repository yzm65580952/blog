# 5.2 无名管道(1)：PIPE编程实例
## Linux内核中的管道
## PIPE的内核层实现
```c
struct pipe_inode_info {
wait_queue_head_t wait;
char *base; //指向管道缓存首地址
unsigned int len; //管道缓存使用的长度
unsigned int start; //读缓存开始的位置
unsigned int readers;
unsigned int writers;
unsigned int waiting_writers;
unsigned int r_counter;
unsigned int w_counter;
struct fasync_struct *fasync_readers;
struct fasync_struct *fasync_writers;
};
```
##  管道是一个文件 (pipefs)
– 内核将一个缓冲区与管道文件进行关联、封装
– 用户可通过open/read/write/close等I/O接口进行读写

##  管道
• 像一个管道连接两个进程
• 一个进程的输出作为另一个进程的输入
• 用于亲缘进程之间的通信：共享资源

## 创建一个管道
1. 函数原型：
– int pipe (int pipefd[2]);
– int pipe2(int pipefd[2], int flags);
2. 函数参数：管道的两个文件描述符：一个用来读、一个用来写

## 无名管道
```c
/************************************************
*      Filename: pipe.c
*        Author: litao.wang
*    Bug Report: 3284757626@qq.com
*   Description: 
*        Create: 2019-06-14 06:05:29
* Last Modified: 2019-07-17 15:16:03
*************************************************/
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <errno.h>

#define handle_error(msg) \
    {perror(msg);exit(EXIT_FAILURE);}

int main (int argc, char *argv[])
{
	int pipe_fd[2]; 
	if (pipe (pipe_fd) == -1) //将管道注册到内核
        handle_error("pipe");

	int ret_from_fork;
	ret_from_fork = fork ();	//创建子进程
	if (ret_from_fork == -1)
        handle_error("fork");

	if (ret_from_fork == 0)   //child process
	{
		char str[100] = {0}; 
		printf("child process:\n input string:");
		scanf ("%s", str);
		//gets(str);
		write (pipe_fd[1], str, strlen (str)); //子进程往管道写 write data to pipe
		close (pipe_fd[1]);
		_exit (EXIT_SUCCESS);
	}

	if (ret_from_fork > 0)   // parent process
	{
		char buf[30] = {0};
		read (pipe_fd[0], buf, 30); //父进程读管道 read data from pipe
		printf ("parent process: %s\n", buf);
		close (pipe_fd[0]);
		exit (EXIT_SUCCESS);
	}

	return 0;
}

```

## 双管道实现双向通信
```c
/************************************************
*      Filename: pipe-v2.c
*        Author: litao.wang
*    Bug Report: 3284757626@qq.com
*   Description: 
*        Create: 2019-06-14 06:05:29
* Last Modified: 2019-07-17 15:26:43
*************************************************/
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <errno.h>

#define handle_error(msg) \
    {perror(msg);exit(EXIT_FAILURE);}

int main (int argc, char *argv[])
{
	int pipe_fd1[2]; 	//定义连个管道
	int pipe_fd2[2]; 
	if (pipe (pipe_fd1) == -1 || pipe (pipe_fd2) == -1) 
        handle_error("pipe");

	int ret_from_fork;
	ret_from_fork = fork ();	//创建子进程
	if (ret_from_fork == -1)
        handle_error("fork");
	if (ret_from_fork == 0)   //child process
	{
		char read_buf1[100] = {0}; 
		char write_buf1[100] = {0}; 
		printf("child process:");
		scanf ("%s", write_buf1);
		//gets(str);
		write (pipe_fd1[1], write_buf1, strlen (write_buf1));
		//子进程写管道1
		close (pipe_fd1[1]);

		//sleep(5);
		read (pipe_fd2[0], read_buf1, 100);
		//子进程读管道2
		printf ("in child process: %s\n", read_buf1);
		close (pipe_fd2[0]);
		_exit (EXIT_SUCCESS);
	}

	if (ret_from_fork > 0)   // parent process
	{
		char read_buf2[100] = {0};
		char write_buf2[100] = {0};
		read (pipe_fd1[0], read_buf2, 100); // read data from pipe
		//夫进程读管道1
		printf ("in parent process: %s\n", read_buf2);
		close (pipe_fd1[0]);

		printf ("parent process:");
		scanf ("%s", write_buf2);
		write (pipe_fd2[1], write_buf2, strlen (write_buf2));
		//父进程写管道2
		close (pipe_fd2[1]);
		exit (EXIT_SUCCESS);
	}

	return 0;
}
```