# 5.19 消息队列(中)：异步通知
## POSIX消息队列异步通知API介绍
1. 函数原型：int mq_notify(mqd_t mqdes, const struct sigevent * sevp);
2. 函数功能：
– 当空的消息队列到来消息时给进程发送一个通知
– 当执行完相关处理，通知机制结束，可以重新调用mq_notify注册
3. 函数参数：
– mqdes：消息队列的ID
– sevp：通知方式设置

## 关键结构体：sigevent
1. sigev_notify
– SIGEV_NONE：有通知时什么也不做
– SIGEV_SIGNAL：给进程发送一个信号来通知进程
– SIGEV_THREAD/ SIGEV_THREAD_ID
2. sigev_signo：要发送的信号

```c
struct sigevent {
int sigev_notify; /* Notification method */
int sigev_signo; /* Notification signal */
union sigval sigev_value; /* Data passed with notification */
void (*sigev_notify_function) (union sigval); /* Function used for thread notification (SIGEV_THREAD) */
void *sigev_notify_attributes; /* Attributes for notification thread (SIGEV_THREAD) */
pid_t sigev_notify_thread_id; /* ID of thread to signal (SIGEV_THREAD_ID) */
};
```

## 例程
mq_notify.c
gcc mq_notify.c -o notify -lrt
```c
/************************************************
*      Filename: mq_notify.c
*        Author: litao.wang
*    Bug Report: 3284757626@qq.com
*   Description: 
*        Create: 2019-07-16 17:35:55
* Last Modified: 2019-07-22 08:59:34
*************************************************/
#include <stdio.h>
#include <fcntl.h>
#include <sys/stat.h>
#include <mqueue.h>
#include <signal.h>
#include <unistd.h>
#include <stdlib.h>
#include <string.h>

mqd_t mq_id;
char buff[8192];
struct sigevent sigev;	//1.定义sigevent结构体设置异步通知

static void signal_hander (int signo)	//6.信号SIGUSR1的回调函数
{
	ssize_t receive_len;
	mq_notify (mq_id, &sigev);//该函数只有一次有效，需要重新拉起
	receive_len = mq_receive (mq_id, buff, 8192, NULL);
	if (receive_len == -1)
	{
		perror ("mq_receive");
		exit (EXIT_FAILURE);
	}
	printf ("read %ld bytes: %s\n",(long)receive_len, buff);
	return;
}

int main (void)
{
	mq_id = mq_open ("/notify_mqueue", O_RDONLY | O_CREAT, 0644, NULL);
	//2.注册消息队列
	if (mq_id == -1)
	{
		perror ("mq_open");
		exit (EXIT_FAILURE);
	}

	signal (SIGUSR1, signal_hander);	//5.注册信号
	sigev.sigev_notify = SIGEV_SIGNAL;	//3.填写sigevent结构体，通知方式为信号通知SIGEV_SIGNAL
	sigev.sigev_signo  = SIGUSR1;//接收信号为SIGUSR1
	mq_notify (mq_id, &sigev);//4.注册notify

    int count = 0;
	while (1)
    {
        printf ("while loop %d\n", count++);
        sleep (1);
    }
    mq_close (mq_id);
	return 0;
}

```
mq_snd.c
```c
/************************************************
*      Filename: mq_snd.c
*        Author: litao.wang
*    Bug Report: 3284757626@qq.com
*   Description: 
*        Create: 2019-06-14 09:40:00
* Last Modified: 2019-07-21 19:30:32
*************************************************/
#include <stdio.h>
#include <unistd.h>
#include <fcntl.h>
#include <stdlib.h>
#include <string.h>
#include <mqueue.h>

int main (void)
{
	mqd_t mq_id;
	if ((mq_id = mq_open("/notify_mqueue", O_WRONLY | O_CREAT, 0644, NULL)) == -1)
	{
		perror ("mq_open");
		exit (EXIT_FAILURE);
	}

	while (1)
	{
		if (mq_send (mq_id, "hello world", sizeof("hello world"), 1) == -1)
		{
			perror ("mq_receive");
			exit (EXIT_FAILURE);
		}
		printf ("msg send success--------\n");
		sleep (2);
	}

	return 0;
}

```
