# 5.3 无名管道(2)：shell中的管道实现

## Shell中的管道通信
Shell中具有亲缘关系的进程之间传递消息
管道的本质是一个字节流
## 基本流程和重定向功能
1. 封装成进程：fork/exec系统调用
2. 该进程默认打开的stdin 、stdout 、stderr 连接在终端上
3. 运行的命令从键盘读取数据并且把输出和错误消息写到屏幕上
4. 通过重定向，可以从指定文件读取数据，或将数据输出到指定文件
5. 重定向I/O的功能是由shell本身实现的：标准流与文件的连接
6. 程序本身并不知道数据最后流向哪里：只跟标准流打交道
7. 通过命令：cmd > file 告诉shell将 stdout 定位到文件file，于是shell就
将文件描述符与指定的文件连接起来，程序的输出到file，而不是默认的屏幕

## dup函数和dup2函数
1. 将管道和输入输出设备联系起来
2. 输入、输出重定向到某个设备、文件
\#include <unistd.h>
int dup(int oldfd);
int dup2(int oldfd, int newfd);
int dup3(int oldfd, int newfd, int flags);
## dup
复制文件描述符
```c
/************************************************
*      Filename: dup.c
*        Author: litao.wang
*    Bug Report: 3284757626@qq.com
*   Description: 
*        Create: 2019-06-21 09:29:14
* Last Modified: 2019-07-17 17:14:53
*************************************************/
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <unistd.h>
#include <fcntl.h>

int main1 (void)
{
	int fd, new_fd;
	fd = open ("write.txt", O_RDWR | O_CREAT, 0644);
	if (fd == -1)
	{
		perror ("open");
		exit (EXIT_FAILURE);
	}
	new_fd = dup (fd);
    printf ("fd = %d\nnew_fd = %d\n", fd, new_fd);
	write (fd, "hello", strlen("hello"));
	close (fd);
	write (new_fd, "world", strlen("world"));
	close (new_fd);
	return 0;
}

int main (void)
{
	int new_fd;
	new_fd = dup (1);
	write (1, "hello", strlen("hello"));
	write (new_fd, "world\n", strlen("world\n"));
	close (new_fd);
	return 0;
}

```
## dup2
将标准输入，标准输出，标准错误重定向
```c
/************************************************
*      Filename: dup2.c
*        Author: litao.wang
*    Bug Report: 3284757626@qq.com
*   Description: redirect stdout to specified file
*        Create: 2019-06-21 09:37:22
* Last Modified: 2019-07-17 16:38:01
*************************************************/
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <fcntl.h>

#define handler_error(msg) \
    {perror(msg);exit(EXIT_FAILURE);}

int main (void)
{
	int fd, new_fd;
	char *buf = "hello world\n";

	fd = open ("data.log", O_RDWR | O_CREAT, 0644);
	if (fd == -1)
        handler_error("open");

	new_fd = dup2 (fd, 1);
	if (new_fd == -1)
        handler_error("dup2");

	printf ("fd: %d\n new_fd: %d\n", fd, new_fd);
	write (1, buf, strlen(buf));
	close (fd);

	return 0;
}

```

## pipe dup
多级管道的底层逻辑
cat dup.c | grep  include
```c
/************************************************
*      Filename: pipe-dup.c
*        Author: litao.wang
*    Bug Report: 3284757626@qq.com
*   Description: 
*        Create: 2019-06-21 10:18:31
* Last Modified: 2019-07-17 17:37:48
*************************************************/
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>

int main (void)
{
	int pipe_fd[2];
	if (pipe (pipe_fd) == -1)	//注册管道
	{
		perror ("pipe");
		exit (EXIT_FAILURE);
	}
	else
	{
		int ret_from_fork;
		ret_from_fork = fork ();
		if (ret_from_fork == 0)  // child process
		{
		//	close (1);
			dup2 (pipe_fd[1], 1);
			execlp ("cat", "cat", "dup.c", NULL);
		}
		else
		{
		//	close (0);
			dup2 (pipe_fd[0], 0);
			close (pipe_fd[1]);
			execlp ("grep", "grep", "include", NULL);
		}
	}
	return 0;
}
```