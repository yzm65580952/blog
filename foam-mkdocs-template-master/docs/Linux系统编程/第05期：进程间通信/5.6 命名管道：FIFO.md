## 5.6 命名管道：FIFO
1. FIFO文件，有文件名字
– 可以像普通文件一样存储在文件系统之中
– 可以像普通文件一样使用open/read/write读写
– 跟PIPE一样，属于流式文件，不能使用lseek定位
2. 具有写入原子性、可同时对FIFO进行写操作，如日志系统/var/log
3. First In First Out：最先被写入FIFO的数据，最先被读出来
– 默认阻塞读、阻塞写的特性，可以在open的时候进行设置
– 当一个进程打开FIFO的一端时，如果另一端没有打开，该进程会被阻塞

## 系统调用接口
shell命令：mkfifo pathname
函数接口： int mkfifo (const char *pathname, mode_t mode);
函数功能：创建一个FIFO有名管道
函数参数：
– pathname：FIFO管道文件名
– mode：读写权限

## 进程通信示例
### 亲缘关系进程之间通信
```c
/************************************************
*      Filename: fifo_demo.c
*        Author: litao.wang
*    Bug Report: 3284757626@qq.com
*   Description: 
*        Create: 2019-06-14 06:36:55
* Last Modified: 2019-07-18 15:03:34
*************************************************/
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>
#include <fcntl.h>
#include <sys/stat.h>
#include <sys/types.h>

int main (void)
{
	mkfifo ("my_fifo", 0644);	//创建一个fifo文件
	int ret_from_fork;
	int fifo_fd;
	ret_from_fork = fork ();
	if (ret_from_fork == -1)
	{
		perror ("fork");
		exit (EXIT_FAILURE);
	}
	else if (ret_from_fork == 0)
	{
		fifo_fd = open ("my_fifo", O_WRONLY);	//打开fifo
		char buf[100];
		memset (buf, 0, 100);
		printf ("child process(%d) input msg:", getpid ());
		
		fgets (buf, 100, stdin);	//键盘输入字符串到buf缓冲
		int write_len = write (fifo_fd, buf, strlen (buf));
		//写入到fifo
		printf ("%d bytes hace been sent\n", write_len);
		_exit (EXIT_SUCCESS);
	}
	else	//ret_from_forkL>0 父进程
	{
		sleep (1);
		fifo_fd = open ("my_fifo", O_RDONLY);	//打开fifo
		char buf[100];
		memset (buf, 0, 100);
		read (fifo_fd, buf, 100);	//读内容到buf
		printf ("parent process(%d) read msg from FIFO: %s\n", getpid (), buf);
		exit (EXIT_SUCCESS);
	}
	return 0;
}
```

### 非亲缘关系进程之间的通信
write_fifo.c
```c
/************************************************
*      Filename: write_fifo.c
*        Author: litao.wang
*    Bug Report: 3284757626@qq.com
*   Description: 
*        Create: 2019-06-14 06:32:19
* Last Modified: 2019-07-18 14:48:17
*************************************************/
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>
#include <fcntl.h>
#include <sys/stat.h>
#include <sys/types.h>

int main (int argc, char *argv[])
{
	mkfifo ("my_fifo", 0644);
	int fifo_fd = open ("my_fifo", O_WRONLY);
	char buf[100];
	memset (buf, 0, 100);

	fgets (buf, 100, stdin);
	int write_len = write (fifo_fd, buf, strlen (buf));
	printf ("%d bytes have been sended to FIFO.\n", write_len);
	return 0;
}

```
read_fifo.c
```c
/************************************************
*      Filename: read_fifo.c
*        Author: litao.wang
*    Bug Report: 3284757626@qq.com
*   Description: 
*        Create: 2019-06-14 06:36:55
* Last Modified: 2019-07-18 14:47:25
*************************************************/
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>
#include <fcntl.h>
#include <sys/stat.h>
#include <sys/types.h>

int main (int argc, char *argv[])
{
	mkfifo ("my_fifo", 0644);

	int fifo_fd = open ("my_fifo", O_RDONLY);

	char buf[100];
	memset (buf, 0, 100);
	read (fifo_fd, buf, 100);
	printf ("Read from FIFO: %s\n", buf);

	return 0;
}

```

## FIFO与PIPE的区别和联系
1. 联系
在内核中的实现：fs/pipe.c，本质上都是内存中的一块page cache
通过向内核注册pipefs来实现，可以通过I/O接口read、write等访问
2. 区别
匿名管道pipe通过自己的两端读写描述符进行读写操作
命名管道有自己的文件名，可以通过文件名直接进行读写操作
匿名管道pipe一般用于亲缘进程间通信
命名管道FIFO可用于非亲缘进程间通信

