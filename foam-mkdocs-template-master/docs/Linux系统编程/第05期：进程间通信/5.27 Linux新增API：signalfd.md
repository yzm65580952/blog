# 5.27 Linux新增API：signalfd
 ## 信号通信机制优缺点
在软件层次上是对中断机制的一种模拟
信号是进程间通信中唯一的“异步通信机制”
带来的弊端：数据的并发访问、可重入问题
解决方案：将信号抽象为文件，将信号转化为I/O文件操作

## signalfd
将信号抽象为一个文件描述符
将信号的异步处理转换为文件的I/O操作
当有信号发生时，可以对其read
每次read都会阻塞、直到signalfd指定的信号到来
也可以将信号的监听放到select、poll、epoll等监听队列中

## signalfd API
1. 函数原型： int signalfd(int fd, const sigset_t *mask, int flags);
2. 函数功能：创建一个可以对信号进行I/O访问的文件描述符
3. 函数参数：
–fd：-1 创建文件描述符
– mask：进程想通过文件描述符接收的信号集
– flags：
» SFD_NONBLOCK：
» SFD_CLOEXEC：

## demo
```c
#include <sys/signalfd.h>
#include <signal.h>
#include <unistd.h>
#include <stdlib.h>
#include <stdio.h>

#define handle_error(msg) \
do { perror(msg); exit(EXIT_FAILURE); } while (0)

void print_signal (struct signalfd_siginfo *siginfo)
{
    printf ("read signal: %d\n", siginfo->ssi_signo);
    printf ("sending process PID: %d\n", siginfo->ssi_pid);
}

int main (int argc, char *argv[])
{
    sigset_t mask;	//1.定义sigset变量
    int signal_fd;	//定义一个文件描述符
    struct signalfd_siginfo siginfo;
    ssize_t read_len;

    sigemptyset(&mask);			//2.填写sigset
    sigaddset(&mask, SIGINT);
    sigaddset(&mask, SIGQUIT);

    /* Block signals so that they aren't handled
     according to their default dispositions */
	//阻塞掉mask信号集中的信号，不执行他们默认的行为
    if (sigprocmask(SIG_BLOCK, &mask, NULL) == -1)
        handle_error("sigprocmask");

    signal_fd = signalfd(-1, &mask, 0);//3.创建signalfd
    if (signal_fd == -1)
        handle_error("signalfd");

    for (;;) 
    {
        read_len = read(signal_fd, &siginfo, sizeof(struct signalfd_siginfo));
		//4.读取信号的信息保存到siginfo中
        if (read_len != sizeof(struct signalfd_siginfo))
            handle_error("read");

        if (siginfo.ssi_signo == SIGINT) //5.根据信号的类型处理
            print_signal (&siginfo);
        else if (siginfo.ssi_signo == SIGQUIT) 
            print_signal (&siginfo);
        else if (siginfo.ssi_signo == SIGHUP) 
            print_signal (&siginfo);
        else
            printf("Read unexpected signal\n");
        printf ("for loop\n");
    }
}


```
