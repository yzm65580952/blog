# 5.18 消息队列(上)：API编程实例
## POSIX 消息队列相关API
mq_open： 创建或打开一个消息队列
mq_send： 向消息队列写入一条消息
mq_receive：从消息队列中读取一条消息
mq_close： 关闭进程打开的消息队列
mq_unlink： 删除一个消息队列
mq_setattr：设置消息队列一些额外的属性
mq_getattr：获取消息队列一些额外的属性
mq_nofity： 异步通知
## 创建或打开 IPC 对象
1. 函数原型：
– mqd_t mq_open (const char *name, int oflag);
– mqd_t mq_open (const char *name, int oflag, mode_t mode,
struct mq_attr *attr);
2. 函数功能：使用指定名字创建或打开一个对象，返回该对象的句柄
3. 函数参数:
– name：用来标识要创建或打开的对象
– Oflag：O_CREAT/O_EXCL /O_RDONLY /O_WRONLY /O_RDWR /O_NONBLOCK
– Mode：位掩码，权限设置
– Attr：设置消息队列的属性，若为NULL，使用默认属性。Linux3.5以后版本也可通过/proc查看设置
4. 函数返回值
– 成功：返回消息队列的IPC对象描述符
– 失败：返回-1，并设置errno

## 关闭POSIX 消息队列
1. 函数原型：int mq_close(mqd_t mqdes);
2. 函数功能：通过描述符关闭消息队列
3. TIPS：
– POSIX 消息队列在进程终止或执行exec()时会自动被关闭

##  删除一个POSIX 消息队列
1. 函数原型：int mq_unlink (const char *name);
2. 函数功能：
– 删除通过 name 标识的消息队列
– 在所有进程使用完该队列之后销毁该队列。
– 若打开该队列的所有进程已经关闭该队列，立即删除****
## 向 POSIX 消息队列写入消息
1. 函数原型：int mq_send(mqd_t mqdes, const char *msg_ptr,
size_t msg_len, unsigned int msg_prio);
2. 函数功能：将msg_ptr指向的缓冲区中的消息添加到描述符mqdes所引用的消息队列中
3. 函数参数：
– mqdes： 消息队列描述符
– msg_ptr：指向存放消息的缓冲区指针
– msg_len：消息的长度[10,8192]
– msg_prio：消息对队列中按优先级排列，设置为0表示无需优先级

## 从 POSIX 消息队列读取消息
1. ssize_t mq_receive(mqd_t mqdes, char *msg_ptr, size_t msg_len,
unsigned int *msg_prio);
2. 函数功能：
– 从mqdes引用的消息队列中删除一条优先级最高、存放时间最长的消息
– 将删除的消息保存在msg_ptr指针指向的缓冲区
3. 函数参数：
– mqdes： 消息队列描述符
– msg_ptr：指向存放消息的缓冲区指针
– msg_len：msg_ptr所指向的缓冲区长度，要大于消息队列的mq_msgsize
– msg_prio：如不为空，接收到的消息的优先级会被复制到指针指向处
1. 函数返回值
– 成功：返回接收的消息的字节数
– 失败：-1，并设置errno
## 代码
mq_demo.c
```c
/************************************************
*      Filename: mq_demo.c
*        Author: litao.wang
*    Bug Report: 3284757626@qq.com
*   Description: 
*        Create: 2019-07-13 22:21:00
* Last Modified: 2019-07-21 18:27:04
*************************************************/
#include <stdio.h>
#include <unistd.h>
#include <fcntl.h>
#include <stdlib.h>
#include <string.h>
#include <mqueue.h>

#define handle_error(msg) \
   do{perror(msg);exit(EXIT_FAILURE);}while(0)

int main (void)
{
	mqd_t mq_id;
	//1.创建消息队列，创建权限O_RDWR | O_CREAT，文件权限0644
	if ((mq_id = mq_open("/posix_msg_queue", O_RDWR | O_CREAT, 0644, NULL)) == -1)
        handle_error("mq_open");

    struct mq_attr mq_attribute;	//消息队列结构体变量
	if (mq_getattr (mq_id, &mq_attribute) == -1)//2.获取消息队列的属性
        handle_error("mq_getattr");
	printf ("mq_flags: %ld\n", mq_attribute.mq_flags);
	printf ("mq_maxmsg: %ld\n", mq_attribute.mq_maxmsg);
	printf ("mq_msgsize: %ld\n", mq_attribute.mq_msgsize);	//消息的大小
	printf ("mq_curmsgs: %ld\n", mq_attribute.mq_curmsgs);

	int ret_from_fork;
	ret_from_fork = fork ();	//创建子进程
	if (ret_from_fork == 0) // child process
	{
		char msg_buf[mq_attribute.mq_msgsize];
		memset (msg_buf, 0, mq_attribute.mq_msgsize);
        int count = 0;
		while (1)
		{
		//3.子进程不断地从消息队列接收消息，存入msg_buf
			if (mq_receive (mq_id, msg_buf, mq_attribute.mq_msgsize, NULL) == -1)
                handle_error("mq_receive");
			printf ("child process received msg: %s\n", msg_buf);
			//4.打印msg_buf
			sleep (1);
            if (++count % 10 == 0)	//只发送10次
                break;
		}
	}
	else if (ret_from_fork > 0) //parent process
	{
        int count = 0;
		while (1)
		{
			if (mq_send (mq_id, "hello world", sizeof ("hello world"), 1) == -1)
                handle_error("mq_send");
			printf ("parent process: send msg to mqueue success\n");
			sleep (1);
            if (++count % 10 == 0)	//只接收10次
                break;
		}
	}
	else
        handle_error("fork");
    
    mq_close (mq_id);	//关闭消息队列
    sleep (5);

	if (mq_unlink ("/posix_msg_queue") == -1)
        handle_error("mq_unlink");
	return 0;
}

```

## 拆成两个文件
q_snd.c
```c
/************************************************
*      Filename: mq_snd.c
*        Author: litao.wang
*    Bug Report: 3284757626@qq.com
*   Description: 
*        Create: 2019-07-14 09:40:00
* Last Modified: 2019-07-21 17:51:09
*************************************************/
#include <stdio.h>
#include <unistd.h>
#include <fcntl.h>
#include <stdlib.h>
#include <string.h>
#include <mqueue.h>

int main (void)
{
	mqd_t mq_id;
	if ((mq_id = mq_open("/posix_msg_queue", O_WRONLY | O_CREAT, 0644, NULL)) == -1)
	//1.注册消息队列
	{
		perror ("mq_open");
		exit (EXIT_FAILURE);
	}
	while (1)
	{
		if (mq_send (mq_id, "hello world", sizeof("hello world"), 1) == -1)//2.发送消息
		{
			perror ("mq_receive");
			exit (EXIT_FAILURE);
		}
		printf ("msg send success--------\n");
		sleep (1);
	}
    mq_close (mq_id);
	return 0;
}

```

mq_rcv.c
```c
/************************************************
*      Filename: mq_rcv.c
*        Author: litao.wang
*    Bug Report: 3284757626@qq.com
*   Description: 
*        Create: 2019-07-14 09:43:19
* Last Modified: 2019-07-21 17:46:35
*************************************************/
#include <stdio.h>
#include <unistd.h>
#include <fcntl.h>
#include <stdlib.h>
#include <string.h>
#include <mqueue.h>

int main (void)
{
	mqd_t mq_id;
	if ((mq_id = mq_open("/posix_msg_queue", O_RDONLY | O_CREAT, 0644, NULL)) == -1)
	//1.注册消息队列
	{
		perror ("mq_open");
		exit (EXIT_FAILURE);
	}
    struct mq_attr mq_attribute;
	if (mq_getattr (mq_id, &mq_attribute) == -1)//2.获取消息的大小
	{
		perror ("mq_getattr");
		exit (EXIT_FAILURE);
	}

	char msg_buf[mq_attribute.mq_msgsize];//3.定义cher数组来接收消息
	memset (msg_buf, 0, mq_attribute.mq_msgsize);

	while (1)
	{
		//4.接收消息，存入msg_buf
		if (mq_receive (mq_id, msg_buf, mq_attribute.mq_msgsize, NULL) == -1)
		{
			perror ("mq_receive");
			exit (EXIT_FAILURE);
		}
		printf ("%s\n", msg_buf);//5.打印msg_buf
		sleep (1);
	}

    mq_close (mq_id);//6.关闭消息队列

	if (mq_unlink ("/posix_msg_queue") == -1)//7.删除消息队列
	{
		perror ("mq_unlink");
		exit (EXIT_FAILURE);
	}
	return 0;
}

```