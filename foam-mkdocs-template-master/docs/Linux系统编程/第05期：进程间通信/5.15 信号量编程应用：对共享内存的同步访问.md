## 5.15 对共享内存的同步访问
## 对共享内存的同步访问
1. 通过读、写信号量实现对共享内存的同步互斥访问
2. 实现一个二元信号量协议
– 读信号量：当为1时，读进程才能进行P操作、读取数据，否则会阻塞
– 写信号量：当为1时，写进程才能进行p操作、写入数据，否则会阻塞
## 代码
shm_write.c
```c
/************************************************
*      Filename: shm_write.c
*        Author: litao.wang
*    Bug Report: 3284757626@qq.com
*   Description: 
*        Create: 2019-07-14 19:05:37
* Last Modified: 2019-07-20 16:20:04
*************************************************/
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <errno.h>
#include <string.h>
#include <strings.h>
#include <sys/stat.h>
#include <sys/ipc.h>
#include <sys/sem.h>
#include <sys/shm.h>

union semun			//semctl函数调用的联合体
{
	int val;
	struct semid_ds *buf;
	unsigned short int *array;
	struct seminfo *__buf;
};

int sem_id;

void sem_init (int semid, int nsignum, int sem_value)//初始化信号量的值
{
	union semun sem_union;
	sem_union.val = sem_value;
	if (semctl (semid, nsignum, SETVAL, sem_union) == -1)
	{
		perror ("semctl");
		exit (EXIT_FAILURE);
	}
}
 void sem_p (int semid, int nsignum)
 //对信号量做-1操作，nsignum为信号量在数组里的索引
{
	struct sembuf sops;
	sops.sem_num = nsignum;
	sops.sem_op  = -1;
	sops.sem_flg = SEM_UNDO;
	if (semop (sem_id, &sops, 1) == -1)
	{
		perror ("semop");
		exit (EXIT_FAILURE);
	}
}
 void sem_v (int semid, int nsignum)
 //对信号量做+1操作，nsignum为信号量在数组里的索引
{
	struct sembuf sops;
	sops.sem_num = nsignum;
	sops.sem_op  = 1;
	sops.sem_flg = SEM_UNDO;
	if (semop (sem_id, &sops, 1) == -1)
	{
		perror ("semop");
		exit (EXIT_FAILURE);
	}
}

void sem_print (int sem_id, int nsignum)//打印信号量的值
{
	int sem_value;
	sem_value = semctl (sem_id, nsignum, GETVAL);
	printf ("sem[%d] = %d\n", nsignum, sem_value);
}
int main (void)
{
	int shm_id;
	key_t shm_key = ftok ("./", 5151);//1.注册ket
	key_t sem_key = ftok ("./", 5152);

	shm_id = shmget (shm_key, 1028, IPC_CREAT | 0644);//2.注册内存映射
	char *shm_addr = shmat (shm_id, NULL, 0);

	sem_id = semget (sem_key, 2, IPC_CREAT | 0644);//3.注册2个信号量
	if (sem_id == -1)
	{
		sem_id = semget (sem_key, 2, 0644);
	}
	
	else	//3.信号量注册成功初始化信号量
	{
		sem_init (sem_id, 0, 0); //sem[0]: for read
		sem_init (sem_id, 1, 1); //sem[1]: for write
	}
	while (1)           //write
	{
		sem_p (sem_id, 1);	//写信号量-1 ，变为负进程挂起
		fgets (shm_addr, 1028, stdin);//写数据
		sem_v (sem_id, 0);	//读信号量+1
	}
	return 0;
}

```

shm_read.c
```c
/************************************************
*      Filename: shm_read.c
*        Author: litao.wang
*    Bug Report: 3284757626@qq.com
*   Description: 
*        Create: 2019-07-14 19:10:53
* Last Modified: 2019-07-20 16:20:04
*************************************************/
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <errno.h>
#include <string.h>
#include <strings.h>
#include <sys/stat.h>
#include <sys/ipc.h>
#include <sys/sem.h>
#include <sys/shm.h>
#include <sys/types.h>

union semun
{
	int val;
	struct semid_ds *buf;
	unsigned short int *array;
	struct seminfo *__buf;
};

int sem_id;

void sem_init (int semid, int nsignum, int sem_value)
{
	union semun sem_union;
	sem_union.val = sem_value;
	if (semctl (semid, nsignum, SETVAL, sem_union) == -1)
	{
		perror ("semctl");
		exit (EXIT_FAILURE);
	}
}
 void sem_p (int semid, int nsignum)
{
	struct sembuf sops;
	sops.sem_num = nsignum;
	sops.sem_op  = -1;
	sops.sem_flg = SEM_UNDO;
	if (semop (sem_id, &sops, 1) == -1)
	{
		perror ("semop");
		exit (EXIT_FAILURE);
	}
}
 void sem_v (int semid, int nsignum)
{
	struct sembuf sops;
	sops.sem_num = nsignum;
	sops.sem_op  = 1;
	sops.sem_flg = SEM_UNDO;
	if (semop (sem_id, &sops, 1) == -1)
	{
		perror ("semop");
		exit (EXIT_FAILURE);
	}
}

void sem_print (int sem_id, int nsignum)
{
	int sem_value;
	sem_value = semctl (sem_id, nsignum, GETVAL);
	printf ("sem[%d] = %d\n", nsignum, sem_value);
}
int main (void)
{
	int shm_id;
	key_t shm_key = ftok ("./", 5151);
	key_t sem_key = ftok ("./", 5152);

	shm_id = shmget (shm_key, 1028, IPC_CREAT | 0644);
	char *shm_addr = shmat (shm_id, NULL, 0);

	sem_id = semget (sem_key, 2, IPC_CREAT | 0644);
	if (sem_id == -1 )
	{
		perror ("semget");
		exit (EXIT_FAILURE);
	}
	else
	{
		sem_init (sem_id, 0, 0);//sem[0]: for read
		sem_init (sem_id, 1, 1);//sem[1]: for write
	}
	while (1)            //read
	{
		sem_p (sem_id, 0);	//读信号量-1 ，负数,进程挂起
		printf ("from shm:%s", shm_addr);
		sem_v (sem_id, 1);	//写信号量+1
	}
	return 0;
}

```