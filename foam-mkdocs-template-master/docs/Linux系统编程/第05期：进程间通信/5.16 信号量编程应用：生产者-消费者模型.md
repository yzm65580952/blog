# 5.16 信号量编程应用：生产者-消费者模型
## 生产消费者模型
1. 有若干个缓冲区，生产者不断往里填数据，消费者不断从里面取数据
2. 如何使两者不产生冲突呢？
– 缓冲区只有若干个，且有固定大小，而生产者和消费者则有多个进程
– 生产者往缓冲区填数据前要判断缓冲区是否满了，满了就会等，直到有空间
– 消费者从缓冲区拿数据之前要判断缓冲区是否为空，空了就会等，直到缓冲区内有数据为止
– 在某一个时刻，缓冲区只允许有一个操作者进行读或写操作

## 生产消费者模型
2个生产者，每1S、5S往缓冲区写一次数据
3个消费者，每2S、2S、5S往缓冲区读一次数据
2个写进程分别对写信号量做P操作、对读信号量做V操作
3个读进程分别对写信号量做V操作、对读信号量做P操作
## 代码
producer.c
```c
/************************************************
*      Filename: producer.c
*        Author: litao.wang
*    Bug Report: 3284757626@qq.com
*   Description: 
*        Create: 2019-07-14 19:05:37
* Last Modified: 2019-07-20 16:44:50
*************************************************/
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <errno.h>
#include <string.h>
#include <strings.h>
#include <sys/stat.h>
#include <sys/ipc.h>
#include <sys/sem.h>
#include <sys/shm.h>

void mem_write (int *addr, int data)
{
	int index;
	index = addr[0];
	index++;
	addr[index] = data;
	addr[0] = index;
	//printf ("index = %c\n", index);
}

union semun
{
	int val;
	struct semid_ds *buf;
	unsigned short int *array;
	struct seminfo *__buf;
};

int sem_id;

void sem_init (int semid, int nsignum, int sem_value)
{
	union semun sem_union;
	sem_union.val = sem_value;
	if (semctl (semid, nsignum, SETVAL, sem_union) == -1)
	{
		perror ("semctl");
		exit (EXIT_FAILURE);
	}
}
 void sem_p (int semid, int nsignum)
{
	struct sembuf sops;
	sops.sem_num = nsignum;
	sops.sem_op  = -1;
	sops.sem_flg = SEM_UNDO;
	if (semop (sem_id, &sops, 1) == -1)
	{
		perror ("semop");
		exit (EXIT_FAILURE);
	}
}
 void sem_v (int semid, int nsignum)
{
	struct sembuf sops;
	sops.sem_num = nsignum;
	sops.sem_op  = 1;
	sops.sem_flg = SEM_UNDO;
	if (semop (sem_id, &sops, 1) == -1)
	{
		perror ("semop");
		exit (EXIT_FAILURE);
	}
}

void sem_print (int sem_id, int nsignum)
{
	int sem_value;
	sem_value = semctl (sem_id, nsignum, GETVAL);
	printf ("sem[%d] = %d\n", nsignum, sem_value);
}
int main (void)
{
	int shm_id;
	key_t shm_key = ftok ("./", 5161);	//1.注册key
	key_t sem_key = ftok ("./", 5162);

	shm_id = shmget (shm_key, 1028, IPC_CREAT | 0644);//2.注册共享内存的对象
	char *shm_addr = shmat (shm_id, NULL, 0);
	memset (shm_addr, 0, 128);

	sem_id = semget (sem_key, 2, IPC_CREAT | 0644);//3.注册信号量的对象
	if (sem_id == -1)
	{
		sem_id = semget (sem_key, 2, 0644);
	}
	else
	{
		sem_init (sem_id, 0, 0); // for read
		sem_init (sem_id, 1, 5); // 初始化 写信号量，5个写缓冲
	}
	
	int ret_from_fork;	//创建进程
	if ((ret_from_fork = fork()) == -1)
	{
		perror ("fork");
		exit (EXIT_FAILURE);
	}
	else if (ret_from_fork == 0)
	{
		int child_data = 1;	//子进程写1 3 5 7 9
		while (1)           //child process write
		{
			sleep (1);
			sem_p (sem_id, 1);//写信号量-1 ，小于0则挂起
			printf ("child data: %d\n", child_data);
			mem_write ((int *)shm_addr, child_data);
			child_data = child_data + 2;
			sem_v (sem_id, 0);//写完之后读信号量+1
		}
	}
	else
	{
		int parent_data = 2;//父进程写 2 4 6 6 8 10
		while (1)           //parent process write
		{
			sleep (1);
			sem_p (sem_id, 1);
			printf ("parent data: %d\n", parent_data);
			mem_write ((int *)shm_addr, parent_data);
			parent_data = parent_data + 2;
			sem_v (sem_id, 0);
		}

	}

	return 0;
}
```
comsumer.c
```c
/************************************************
*      Filename: comsumer.c
*        Author: litao.wang
*    Bug Report: 3284757626@qq.com
*   Description: 
*        Create: 2019-07-14 19:10:53
* Last Modified: 2019-07-20 16:44:50
*************************************************/
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <errno.h>
#include <string.h>
#include <strings.h>
#include <sys/stat.h>
#include <sys/ipc.h>
#include <sys/sem.h>
#include <sys/shm.h>
#include <sys/types.h>

int mem_read (int *addr)
{
	int index;
	int data;
	index = addr[0];
	data  = addr[index];
	index--;
	addr[0] = index;
	return data;
}


union semun
{
	int val;
	struct semid_ds *buf;
	unsigned short int *array;
	struct seminfo *__buf;
};

int sem_id;

void sem_init (int semid, int nsignum, int sem_value)
{
	union semun sem_union;
	sem_union.val = sem_value;
	if (semctl (semid, nsignum, SETVAL, sem_union) == -1)
	{
		perror ("semctl");
		exit (EXIT_FAILURE);
	}
}
 void sem_p (int semid, int nsignum)
{
	struct sembuf sops;
	sops.sem_num = nsignum;
	sops.sem_op  = -1;
	sops.sem_flg = SEM_UNDO;
	if (semop (sem_id, &sops, 1) == -1)
	{
		perror ("semop");
		exit (EXIT_FAILURE);
	}
}
 void sem_v (int semid, int nsignum)
{
	struct sembuf sops;
	sops.sem_num = nsignum;
	sops.sem_op  = 1;
	sops.sem_flg = SEM_UNDO;
	if (semop (sem_id, &sops, 1) == -1)
	{
		perror ("semop");
		exit (EXIT_FAILURE);
	}
}

void sem_print (int sem_id, int nsignum)
{
	int sem_value;
	sem_value = semctl (sem_id, nsignum, GETVAL);
	printf ("sem[%d] = %d\n", nsignum, sem_value);
}
int main (void)
{
	int shm_id;
	key_t shm_key = ftok ("./", 5161);	//1.初始化key
	key_t sem_key = ftok ("./", 5162);

	shm_id = shmget (shm_key, 1028, IPC_CREAT | 0644);//2.注册共享内存的对象
	char *shm_addr = shmat (shm_id, NULL, 0);//3.映射共享内存
	memset (shm_addr, 0, 128);

	sem_id = semget (sem_key, 2, IPC_CREAT | 0644);//4.注册信号量
	if (sem_id == -1 )
	{
		perror ("semget");
		exit (EXIT_FAILURE);
	}
	else
	{			//5.初始化信号量
		sem_init (sem_id, 0, 0); // init read semaphore
		sem_init (sem_id, 1, 5); //  写信号量，5个写缓冲
	}

	for (int i = 0; i < 2; i++)//创建两个读进程
	{
		int ret_from_fork;
		if ((ret_from_fork = fork()) == -1)
		{
			perror ("fork");
			exit (EXIT_FAILURE);
		}
		else if (ret_from_fork == 0)
		{
			while (1)
			{
				sleep (2);
				sem_p (sem_id, 0);//读信号量-1
				printf ("pid %d data: %d\n", getpid(), mem_read((int *)shm_addr));5.子进程读数据
				sem_v (sem_id, 1);//写信号量+1
			}
		}
	}

	while (1)            //read
	{
		sleep (5);
		sem_p (sem_id, 0);//读信号量-1
		printf ("pid %d data: %d\n", getpid(), mem_read((int *)shm_addr));//父进程读数据
		sem_v (sem_id, 1);//写信号量+1
	}
	return 0;
}
```

## System V 信号量的通信特点
信号量是通过标识符而不是常用的文件描述符来引用的
使用键而不是文件名来标识信号量
创建和初始化信号量需要使用单独的系统调用
内核不会维护引用一个信号量集的进程数量。很多操作需要开发者自己控制
信号量的操作存在诸多限制