# 5.14 system V 信号量
## 什么是信号量
英文：semaphore，简称SEM，主要用来进程间同步
本质：内核维护的一个正整数，可对其进行各种操作+/-操作
分类：system V 信号量、POSIX 有名信号量、POSIX 无名信号量
用途：用来标识系统中可用的共享资源的个数，协调各进程有序地使用这些资源，防止发生冲突
信号量类似于酒店房间的房卡，房间资源是有限的、房卡也是有限的
P操作：程序在进入临界区之前要先对资源进行申请
V操作：程序离开临界区后要释放相应的资源，如房卡交给房东

## 通信原理
类似于房卡，不是单个值，而是一组(实际上是数组)信号量元素构成
将信号量设置成一个绝对值
在信号量当前值的基础上加上一个数量
在信号量当前值的基础上减去一个数量，降到0以下可能会引起阻塞
阻塞进程一直等待其它进程修改信号量的值，直到恢复正常运行
信号量本身无意义，通常会与一块临界资源(如共享内存)关联使用

## 相关API
获取信号量ID：int semget (key_t key, int nsems, int semflg);
P/V操作：int semop (int semid, struct sembuf *sops, size_t nsops);
– 操作术语：荷兰语中的首字母，由荷兰计算机科学家Edsger Dijkstra确定
– 其它操作术语：down(减小信号量)、up(增大信号量)
– POSIX标准：wait、post
信号量设置：int semctl (int semid, int semnum, int cmd, ...);


##  创建或打开一个信号量
1. 函数原型： int semget (key_t key, int nsems, int semflg);
2. 包含头文件： sys/ipc.h sys/sem.h
3. 函数参数：
– key：用来表示信号量的键，通常使用值IPC_PRIVATE或由ftok创建
– nsems：信号的数量，所有的信号放在一个数组内
– semflg：位掩码，用来设置信号量的权限或检查一个已有信号量的权限
» IPC_CREAT：如果找不到指定key相关联的信号量，创建一个新信号量集合
» IPC_EXCL：若指定了IPC_CREAT且指定key关联的信号量存在，报EEXIST错误
4. 函数返回值
– 成功：返回用于操作信号量的句柄ID
– 失败：-1，并设置errno全局变量


## 信号量设置
1. 函数原型： int semctl (int semid, int semnum, int cmd, ...);
2. 包含头文件：
– #include <sys/ipc.h>
– #include <sys/sem.h>
3. 函数参数：
– semid ：用于操作信号量的句柄ID、标识符
– semnum ：信号的数量，所有的信号放在一个数组内
– cmd：
» IPC_RMID：删除信号量集及相关联的内核semid_ds数据结构
» IPC_STAT：获取 semid_ds 副本
» IPC_SET：设置 semid_ds 数据结构
» GETVAL：获取信号集中第semnum个信号量的值
» GETALL：获取所有的信号量的值
» SETVAL：设置信号集中的第semnum个信号量的值
4. 函数返回值
– 成功：根据cmd命令，返回不同的值
– 失败：-1，并设置errno全局变量

##  信号量P/V操作
1. 函数原型： int semop(int semid, struct sembuf *sops, size_t nsops);
2. 包含头文件：
– #include <sys/ipc.h>
– #include <sys/sem.h>
3. 函数参数：
– semid ：用于操作信号量的IPC标识符
– sops ：指向数组的指针，数组中包含了需要执行的操作
– nsops ：数组的大小
4. 函数返回值
– 成功：根据cmd命令，返回不同的值
– 失败：-1，并设置errno全局变量

##  使用流程
1. 使用semget创建或打开一个信号量集
2. 使用semctl SETVAL或SETALL操作初始化集合中的信号量(其中一个进程操作即可，内核中维护，对其它进程是全局可见的)
3. 使用semop操作信号量值。多个进程通过多信号量值的操作来表示一些临界资源的获取和释放
4. 当所有进程不再需要信号量集时，使用semctl IPC_RMID操作删除这个信号量集(其中一个进程操作即可)
## 代码
```c
/************************************************
*      Filename: sem_creat.c
*        Author: litao.wang
*    Bug Report: 3284757626@qq.com
*   Description: semphore basic usage 
*        Create: 2019-06-22 02:07:47
* Last Modified: 2019-07-20 15:33:20
*************************************************/
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>

#include <sys/ipc.h>
#include <sys/sem.h>
#include <sys/types.h>

#define handle_error(msg) \
    {perror(msg);exit(EXIT_FAILURE);}

// creat a semphore
// print and set semphore
// P/V sem value
// delete sem

union semun
{
	int val;
	struct semid_ds *buf;
	unsigned short int *array;
	struct seminfo *__buf;
};

/*
struct sembuf
{
	unsigned short sem_num;//semaphore index in array
	short sem_op;          //sepaphore operation
	short sem_flg;         //operation flags
};
*/

int main (void)
{
	int sem_id;
	key_t key;

	if ((key = ftok(".", 514))== -1)	//1.注册key
        handle_error("ftok");

	if ((sem_id = semget (key, 3, IPC_CREAT | 0770)) == -1)	
	//2.通过key创建信号量，3个
        handle_error("semget");
	printf ("sem id: %d\n", sem_id);

	// get sem value
	int sem_value;
	sem_value = semctl (sem_id, 0, GETVAL);	
	//3.获取信号量的值，0表示取数组中的第一个元素
	printf ("sem value: %d\n", sem_value);

	// set sem value
	union semun sem_union;	//4. 填写要设置的内容到信号量结构体
	sem_union.val = 2;
	semctl (sem_id, 0, SETVAL, sem_union);	//5.设置信号量
	
	sem_value = semctl (sem_id, 0, GETVAL);//6.重新获取信号量的值并打印 
	printf ("sem value: %d\n", sem_value);


	//7. 填写pv操作的结构体 sem p/v operations
	struct sembuf sops;
	sops.sem_num = 0;		//第1个信号量
	sops.sem_op = -1;//减1 if sem value=0, blocked
	sops.sem_flg = SEM_UNDO;//默认
	
	
	if (semop (sem_id, &sops, 1) == -1)
	//8.进行pv操作，1标准只操作1个信号量，如果要操作多个则ops需要为一个数组
        handle_error("sem_op");
	sem_value = semctl (sem_id, 0, GETVAL);
	printf ("sem value: %d\n", sem_value);
	
	sleep (30);
	semctl (sem_id, 0, IPC_RMID);//9.删除信号量

	return 0;
}

```