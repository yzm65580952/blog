# 6.4 解析用户输入的命令并执行
```c

/************************************************
* Copyright(C) zhaixue.cc All rights reserved
*
*      Filename: shell.c
*        Author: litao.wang
*        E-mail: 3284757626@qq.com
*   Description: 
*        Create: 2019-08-20 14:03:55
* Last Modified: 2019-08-20 17:06:07
************************************************/
#include <stdio.h>
#include <unistd.h>
#include <stdlib.h>
#include <sys/types.h>
#include <sys/wait.h>
#include <string.h>

int main (void)
{
    char buffer[512] = {0};
    char c;
    int pos = 0;
    while (1)
    {
        c = getchar ();
        if (c != '\n' && c != EOF)
		//只要不遇到换行符，或者文件结尾
            buffer[pos++] = c;//命令放入buffer
        else
        {
            buffer[pos++] = '\0';//添加结束标记
            break;
        }

    }
    char *arglist[20] = {0};
    char *cp = buffer;
    int  args_num = 0;
    int  len;
    char *start;
	
    while (*cp != '\0')//解析命令
    {
        while (*cp == ' ' || *cp == '\t')
            cp++;// 不理会空格和制表符
        start = cp;//保存起始位置  
        len = 1;
		
        c = *++cp;
        while (c != '\0' && c != ' ' && c != '\t')
        {
            len++;//求出长度
            c = *++cp;
        }
		
        arglist[args_num] = (char *) malloc (len + 1);
        strncpy (arglist[args_num], start, len);
		//将命令字符串复制到arglist[]
        arglist[args_num][len] = '\0';//添加结束标记
        args_num++;//为解析下一个参数做准备，命令以二维数组形式保存
    }
    int ret_from_fork;
    int child_ret_status;
    ret_from_fork = fork ();
    if (ret_from_fork == 0)
    {
        execvp (arglist[0], arglist);
        perror ("execvp");
        exit (EXIT_FAILURE);
    }
    else if (ret_from_fork > 0)
    {
        if(wait (&child_ret_status) == -1)
            perror ("wait");
    }
    else
    {
        perror ("fork");
        exit (EXIT_FAILURE);
    }
    int i = 0;
    while (arglist[i])
        free (arglist[i++]);//释放内存
    printf ("main shell exit\n");
    return 0;
}

```