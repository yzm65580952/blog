# 6.7 实现shell内建命令：cd

## builtin_cmd.c
```c
/************************************************
* Copyright(C) zhaixue.cc All rights reserved
*
*      Filename: builtin_cmd.c
*        Author: litao.wang
*        E-mail: 3284757626@qq.com
*   Description: 
*        Create: 2019-08-21 10:53:54
* Last Modified: 2019-08-21 11:06:28
************************************************/
#include <stdio.h>
#include <unistd.h>
#include <string.h>
int builtin_cmd_cd (char path[])
{
    int ret;
    ret = chdir (path);
    if (ret == -1)
    {
        printf ("cd %s failed\n", path);
        return -1;
    }
    return 0;
}

int is_builtin_cmd (char *arglist[])//判断是否时内建命令
{
    if (strcmp (arglist[0], "cd") == 0)
        return 1;
    if (strcmp (arglist[0], "test") == 0)
        return 1;
    return 0;
}

```
## shell.c
```c

/************************************************
* Copyright(C) zhaixue.cc All rights reserved
*
*      Filename: shell.c
*        Author: litao.wang
*        E-mail: 3284757626@qq.com
*   Description: 
*        Create: 2019-08-20 14:03:55
* Last Modified: 2019-08-21 11:07:07
************************************************/
#include <stdio.h>
#include <unistd.h>
#include <stdlib.h>
#include <sys/types.h>
#include <sys/wait.h>
#include <string.h>
#include <pwd.h>
int read_cmdline  (char buffer[]);
int parse_cmdline (char buffer[], char *arglist[]);
int exec_cmdline  (char *arglist[]);
int free_cmdline  (char *arglist[], int args_num);
void print_cmd_prompt (void);
int main (void)
{
    char buffer[512] = {0};
    char *arglist[20] = {0};
    int args_num = 0;
    while (1)
    {
        print_cmd_prompt ();
        read_cmdline (buffer);
        args_num = parse_cmdline (buffer, arglist);
        exec_cmdline (arglist);
        free_cmdline (arglist, args_num);
        memset (buffer, '\0', 512);
        memset (arglist, 0, 80);
    }

    printf ("main shell exit\n");
    return 0;
}

void print_cmd_prompt (void)
{
    struct passwd *pwd;
    pwd = getpwuid (getuid());
    char path[256];
    getcwd (path, sizeof(path));
    printf ("\033[33;1m%s@wsh:\033[34;1m%s\033[0m >>>", pwd->pw_name, path);
}

int read_cmdline (char buffer[])
{
    char c;
    int pos = 0;
    while (1)
    {
        c = getchar ();//接收字符串
        if (c != '\n' && c != EOF)
            buffer[pos++] = c;
        else
        {
            buffer[pos++] = '\0';
            break;
        }

    }
    return pos;
}

int parse_cmdline (char buffer[], char *arglist[])
{
    int  args_num = 0;
    char *cp = buffer;
    int  len;
    char *start;
    char c;
    while (*cp != '\0')
    {
        while (*cp == ' ' || *cp == '\t')
            cp++;
        if (*cp == 0)
            break;
        start = cp;
        len = 1;
        c = *++cp;
        while (c != '\0' && c != ' ' && c != '\t')
        {
            len++;
            c = *++cp;
        }
        arglist[args_num] = (char *) malloc (len + 1);
        strncpy (arglist[args_num], start, len);
        arglist[args_num][len] = '\0';
        args_num++;
    }
    return args_num;
}
int builtin_cmd_cd (char path[]);
int is_builtin_cmd (char *arglist[]);
int exec_cmdline (char *arglist[])
{
    if (arglist[0] == 0)
        return 0;
    if (is_builtin_cmd(arglist))//判断是否时内建命令
    {
        builtin_cmd_cd(arglist[1]);//操作对应的目录arglist[1]
        return 0;
    }
    int ret_from_fork;
    int child_ret_status;
    ret_from_fork = fork ();
    if (ret_from_fork == 0)
    {
        execvp (arglist[0], arglist);
        perror ("execvp");
        exit (EXIT_FAILURE);
    }
    else if (ret_from_fork > 0)
    {
        if(wait (&child_ret_status) == -1)
            perror ("wait");
    }
    else
    {
        perror ("fork");
        exit (EXIT_FAILURE);
    }
    return 0;
}

int free_cmdline (char *arglist[], int args_num)
{
    int i;
    for (i = 0; i < args_num; i++)
        free (arglist[i]);
    return 0;
}

```

## Makefile
```c
.PHONY: all clean
SRCS = $(wildcard *.c)	//wildcard通配符 搜索所有的.c文件
BIN  = wsh		//生成的可执行文件

all:$(BIN)
$(BIN):$(SRCS)
	gcc -Wall -o $@ $^	//$^ 所有依赖文件 $@ 目标文件
clean:
	rm -f $(BIN)

```