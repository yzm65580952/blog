# 3.9 将文件映射到内存
## 用户空间的IO缓存优缺点
优点：减少了系统调用的次数，减少了系统开销
缺点：增加了数据拷贝次数，增大了CPU和内存开销
– 读：数据从内核页缓存拷贝到标准IO缓存，再拷贝到用户的buffer
– 写：数据从用户的buffer拷贝到标准IO缓存，再拷贝到内核缓冲区

## 将文件映射到内存
内存地址与文件数据一一对应
通过内存代替read/write 等I/O系统调用接口来访问文件
减少内存拷贝、减少系统调用次数，提高系统性能
## 内存映射系统调用接口
mmap以页为单位操作：参数addr和offset必须按页对齐
```c
 void *mmap(void *addr, size_t length, int prot, int flags,int fd, off_t offset);
// addr：进程中要映射的虚拟内存起始地址，一般为NULL
// length：要映射的内存区域大小
// prot：内存保护标志： PROT_EXEC、 PROT_READ、 PROT_WRITE
// flags：映射对象类型： MAP_FIXED、 MAP_SHARED、MAP_PRIVATE
// fd：要映射文件的文件描述符
// offset：文件位置偏移

```


## mmap_read.c

```c
#include <sys/mman.h>
#include <sys/types.h>
#include <fcntl.h>
#include <string.h>
#include <stdio.h>
#include <unistd.h>

int main (int argc, char *argv[])
{
	int fd;
	int i;
	char *p_map;
	fd = open (argv[1], O_CREAT | O_RDWR, 0666);
	p_map = (char *) mmap (NULL, 20, PROT_READ | PROT_WRITE, MAP_SHARED, fd, 0);
	/*
	映射到内存
	进程中要映射的虚拟内存起始地址 NULL
	要映射的内存区域大小 20
	内存保护标志 读写
	映射对象类型 MAP_SHARED 多个进程共享
	要映射文件的文件描述符 fd
	文件位置偏移 0
	*/
	
	if (p_map == MAP_FAILED)
	{
		perror ("mmap");
		return -1;
	}
	close (fd);
	if (fd == -1)
	{
		perror ("close");
		return -1;
	}
	
	printf ("%s", p_map);	//打印虚拟地址
	
	if (munmap (p_map, 20) == -1)
	{
		perror ("munmap");
		return -1;
	}
	return 0;
}

```

## mmap_write.c
```c
#include <sys/mman.h>
#include <sys/types.h>
#include <fcntl.h>
#include <string.h>
#include <stdio.h>
#include <unistd.h>

int main (int argc, char *argv[])
{
	int fd;
	int i;
	char *p_map;
	fd = open (argv[1], O_CREAT | O_RDWR | O_TRUNC, 0666);
	write (fd, "", 1);
	p_map = (char *) mmap (NULL, 20, PROT_READ | PROT_WRITE, MAP_SHARED, fd, 0);
	/*
	映射到内存
	进程中要映射的虚拟内存起始地址 NULL
	要映射的内存区域大小 20
	内存保护标志 读写
	映射对象类型 MAP_SHARED 多个进程共享
	要映射文件的文件描述符 fd
	文件位置偏移 0
	*/
	
	if (p_map == MAP_FAILED)
	{
		perror ("mmap");
		return -1;
	}
	close (fd);
	if (fd == -1)
	{
		perror ("close");
		return -1;
	}
	
	memcpy (p_map, "hello world!\n", 14);//写虚拟地址
	sleep (5);
	if (munmap (p_map, 20) == -1)
	{
		perror ("munmap");
		return -1;
	}
	return 0;
}

```