# 3.5 块设备驱动架构
## Linux内核中的块缓存
1. 早期使用块缓存，新的内核逐渐使用页缓存
2. 块缓存：比页缓存小、长度可变，依赖于设备(或文件系统)
3. 块缓存的实现：基于页缓存
– 缓冲头：buffer_head，缓冲区的元数据信息：块号、块长度
– 每个buffer_head指向一个缓冲区，一个页可以细分为若干个缓冲区
– 内核物理页与磁盘物理块之间的桥梁

## 块缓存
```c
struct buffer_head {
unsigned long b_state;  /* buffer state bitmap (see above) */
struct buffer_head *b_this_page; /* circular list of page's buffers */
struct page *b_page; /* the page this bh is mapped to */
sector_t b_blocknr; /* start block number */
size_t b_size;  /* size of mapping */
char *b_data; /* pointer to data within the page */
struct block_device *b_bdev;
bh_end_io_t *b_end_io; /* I/O completion */
void *b_private; /* reserved for b_end_io */
struct list_head b_assoc_buffers; /* associated with another mapping */
struct address_space *b_assoc_map; /* mapping this buffer is
associated with */
atomic_t b_count; /* users using this buffer_head */
};
```
## bio结构体
1. main unit of I/O for the block layer and lower layers
2. struct gendisk -> block_device -> /dev/sdax -> inode
```c
struct bio {
struct bio *bi_next; /* request queue link */
struct block_device  *bi_bdev;
unsigned int  bi_flags;  /* status, command, etc */
unsigned long  bi_rw; 
struct bvec_iter  bi_iter;
unsigned int  bi_phys_segments;
unsigned int  bi_seg_front_size;
unsigned int  bi_seg_back_size;
atomic_t __bi_remaining;
bio_end_io_t  *bi_end_io;
void  *bi_private;
unsigned short  bi_vcnt;  /* how many bio_vec's */
unsigned short  bi_max_vecs; /* max bvl_vecs we can hold */
atomic_t __bi_cnt; /* pin count */
struct bio_vec  *bi_io_vec; /* the actual vec list */
struct bio_set  *bi_pool;
struct bio_vec  bi_inline_vecs[0];
};
```

