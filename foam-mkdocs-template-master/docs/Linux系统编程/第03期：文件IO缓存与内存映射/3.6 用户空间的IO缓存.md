# 3.6 用户空间的IO缓存
## 系统调用的开销
切换CPU到内核模式
数据拷贝
切换CPU到用户模式
## C标准库IO缓冲区
1. 在用户空间，为每个打开的文件
– 分配一个I/O缓冲区
– 分配一个文件描述符
– I/O缓冲区信息和文件描述符一起封装在FILE结构体中
2. size_t fread(void *ptr, size_t size, size_t nmemb, FILE *stream);
3.  size_t fwrite(const void *ptr, size_t size, size_t nmemb,FILE *stream);

## FILE结构体
```c
struct _IO_FILE {
int _flags; 
char* _IO_read_ptr; /* Current read pointer */
char* _IO_read_end; /* End of get area. */
char* _IO_read_base; /* Start of putback+get area. */
char* _IO_write_base;  /* Start of put area. */
char* _IO_write_ptr; /* Current put pointer. */
char* _IO_write_end; /* End of put area. */
char* _IO_buf_base; /* Start of reserve area. */
char* _IO_buf_end;  /* End of reserve area. */
struct _IO_FILE *_chain;
int  _fileno;
_IO_off_t _old_offset; /* This used to be _offset but it's too small. */
unsigned short _cur_column;
signed char _vtable_offset;
char _shortbuf[1];
_IO_lock_t *_lock;
};
typedef struct _IO_FILE FILE;
```

## 文件读写流程
![[Pasted image 20201004190013.png]]

## 三种模式
1. 块缓冲(block_buffered)：
– 固定字节的缓冲区大小，比如跟文件相关的流都是块缓冲
– 标准IO称块缓冲为完全缓冲(full buffering)
2. 行缓冲(line_buffered)：
– 遇到换行符，缓冲区的数据会拷贝到内核缓冲区
3. 无缓冲(unbuffered)：
– 数据直接拷贝到内核缓冲区
– 如：标准错误stderr采用无缓冲模式

## 自定义缓冲区
### setvbuf
```c
int setvbuf (FILE *stream, char *buf, int mode, size_t size);
stream：指向流的指针
buf：缓冲区地址
mode：缓冲区类型
– __IOFBF：当缓冲区为空，从流中读入数据；缓冲区满时向流写入数据
– __IOLBF：每次从流中读入一行数据或向流中写入一行数据
– __IONBF：直接从流中读入数据或直接向流中写入数据，无缓冲区
size：缓冲区内字节的数量
```
