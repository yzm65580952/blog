# 2.15-2.17：实现 wc 命令
## 统计目录的代码行数
find -name "*.c" | xargs cat | wc -l

## 一个工具 wc，统计Linux最新内核源码：
一共有多少个C文件？
一共有多少个H文件？
一共有多少个汇编文件？
一共有多少个words、行？
整个项目一共有多少行代码？

## 思路
先统计单个C文件的字数、代码行数	
然后遍历一个目录下的所有C文件
如果该目录下面还有子目录、递归遍历
统计、累加
打印输出

```c

/************************************************
*      Filename: wc.c
*        Author: litao.wang
*    Bug Report: 3284757626@qq.com
*   Description: 
*        Create: 2018-11-24 16:53:27
* Last Modified: 2018-11-24 18:33:50
*************************************************/
#include <stdio.h>
#include <dirent.h>
#include <string.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <unistd.h>

int do_wc (char filename[]);
int foreach_dir (char dirname[]);

int main (int argc, char *argv[])
{
	foreach_dir (argv[1]);
	return 0;
}
int foreach_dir (char dirname[])	//封装以便支持递归
{
	DIR *dir_ptr;
	struct dirent *entry_ptr;
	dir_ptr = opendir (dirname);//打开目录
	
	if (dir_ptr == NULL)
	{
		perror ("opendir");
		return -1;
	}

	char full_path_name[128];
	struct stat buf;
	while ((entry_ptr = readdir (dir_ptr)) != NULL)
	{
		if ((strcmp (entry_ptr->d_name, ".") && strcmp (entry_ptr->d_name, "..")) == 0)
			continue;	//不统计. 和.. 目录
			
		//重新拼接路径
		strcpy (full_path_name, dirname);
		if (full_path_name[strlen (full_path_name) - 1] != '/')
			strcat (full_path_name, "/");	//如果参数的结尾不是/则增加一个
		strcat (full_path_name, entry_ptr->d_name);

		if (stat (full_path_name, &buf) < 0)
		{
			perror ("stat");
			return -1;
		}
		if (S_ISDIR (buf.st_mode))			//是一个目录，递归调用
			foreach_dir (full_path_name);
		else
		{
			if (strcmp (entry_ptr->d_name + strlen (entry_ptr->d_name) - 2, ".c") && \
				strcmp (entry_ptr->d_name + strlen (entry_ptr->d_name) - 2, ".h") && \
				strcmp (entry_ptr->d_name + strlen (entry_ptr->d_name) - 2, ".S"))
				continue;//只统计.c .s .h 文件
			else
				do_wc (full_path_name);	//开始wc任务
		}

	}
	closedir (dir_ptr);
	return 0;
}

int do_wc (char filename[])	//封装成函数
{
	FILE *fp;
	char ch;
	static unsigned int lines = 0;	//申请变量
	static unsigned int words = 0;
	static unsigned int files = 0;
	int word_flag = 0;
	fp = fopen (filename, "r");
	if (fp == NULL)
	{
		perror ("fopen");
		return -1;
	}
	while ((ch = fgetc (fp)) != EOF)
	{
		if (ch == '\n')	//统计行数
			lines++;
		if (ch == '\n' || ch == ' ' || ch == '\t')	//统计单词数,英文
		{
			word_flag = 1;	//统计单词的辅助标志，支持连续的空格或换行
			continue;
		}
		else
		{
			if (word_flag == 1)
			{
				words++;
				word_flag = 0;
			}
		}
	}
	fclose (fp);
	printf ("%s\n", filename);
	printf ("files: %d\n", ++files);
	printf ("lines: %d\n", lines);
	printf ("words: %d\n", words);
	return 0;
}

```